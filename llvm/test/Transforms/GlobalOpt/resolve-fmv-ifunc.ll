; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --filter "call i32 @(test_single_bb_resolver|test_multi_bb_resolver|test_caller_feats_not_implied|test_non_fmv_caller|test_priority)" --version 4
; RUN: opt --passes=globalopt -o - -S < %s | FileCheck %s

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

$test_single_bb_resolver.resolver = comdat any
$test_multi_bb_resolver.resolver = comdat any
$test_caller_feats_not_implied.resolver = comdat any
$test_non_fmv_caller.resolver = comdat any
$test_priority.resolver = comdat any

@__aarch64_cpu_features = external local_unnamed_addr global { i64 }

@test_single_bb_resolver = weak_odr ifunc i32 (), ptr @test_single_bb_resolver.resolver
@test_multi_bb_resolver = weak_odr ifunc i32 (), ptr @test_multi_bb_resolver.resolver
@test_caller_feats_not_implied = weak_odr ifunc i32 (), ptr @test_caller_feats_not_implied.resolver
@test_non_fmv_caller = weak_odr ifunc i32 (), ptr @test_non_fmv_caller.resolver
@test_priority = weak_odr ifunc i32 (), ptr @test_priority.resolver

declare void @__init_cpu_features_resolver() local_unnamed_addr

declare i32 @test_single_bb_resolver.default() #0

declare i32 @test_single_bb_resolver._Msve() #1

declare i32 @test_single_bb_resolver._Msve2() #2

define weak_odr ptr @test_single_bb_resolver.resolver() #0 comdat {
; CHECK-LABEL: define weak_odr ptr @test_single_bb_resolver.resolver(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] comdat {
resolver_entry:
  tail call void @__init_cpu_features_resolver()
  %0 = load i64, ptr @__aarch64_cpu_features, align 8
  %1 = and i64 %0, 68719476736
  %.not = icmp eq i64 %1, 0
  %2 = and i64 %0, 1073741824
  %.not3 = icmp eq i64 %2, 0
  %test_single_bb_resolver._Msve.test_single_bb_resolver.default = select i1 %.not3, ptr @test_single_bb_resolver.default, ptr @test_single_bb_resolver._Msve
  %common.ret.op = select i1 %.not, ptr %test_single_bb_resolver._Msve.test_single_bb_resolver.default, ptr @test_single_bb_resolver._Msve2
  ret ptr %common.ret.op
}

define i32 @foo._Msve() #1 {
; CHECK-LABEL: define i32 @foo._Msve(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR1:[0-9]+]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_single_bb_resolver._Msve()
;
entry:
  %call = tail call i32 @test_single_bb_resolver()
  ret i32 %call
}

define i32 @foo._Msve2() #2 {
; CHECK-LABEL: define i32 @foo._Msve2(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR2:[0-9]+]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_single_bb_resolver._Msve2()
;
entry:
  %call = tail call i32 @test_single_bb_resolver()
  ret i32 %call
}

define i32 @foo.default() #0 {
; CHECK-LABEL: define i32 @foo.default(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_single_bb_resolver.default()
;
entry:
  %call = tail call i32 @test_single_bb_resolver()
  ret i32 %call
}

declare i32 @test_multi_bb_resolver._Mmops() #3

declare i32 @test_multi_bb_resolver._Msve2() #2

declare i32 @test_multi_bb_resolver._Msve() #1

declare i32 @test_multi_bb_resolver.default() #0

define weak_odr ptr @test_multi_bb_resolver.resolver() #0 comdat {
; CHECK-LABEL: define weak_odr ptr @test_multi_bb_resolver.resolver(
; CHECK-SAME: ) #[[ATTR0]] comdat {
resolver_entry:
  tail call void @__init_cpu_features_resolver()
  %0 = load i64, ptr @__aarch64_cpu_features, align 8
  %1 = and i64 %0, 576460752303423488
  %.not = icmp eq i64 %1, 0
  br i1 %.not, label %resolver_else, label %common.ret

common.ret:                                       ; preds = %resolver_else2, %resolver_else, %resolver_entry
  %common.ret.op = phi ptr [ @test_multi_bb_resolver._Mmops, %resolver_entry ], [ @test_multi_bb_resolver._Msve2, %resolver_else ], [ %test_multi_bb_resolver._Msve.test_multi_bb_resolver.default, %resolver_else2 ]
  ret ptr %common.ret.op

resolver_else:                                    ; preds = %resolver_entry
  %2 = and i64 %0, 68719476736
  %.not5 = icmp eq i64 %2, 0
  br i1 %.not5, label %resolver_else2, label %common.ret

resolver_else2:                                   ; preds = %resolver_else
  %3 = and i64 %0, 1073741824
  %.not6 = icmp eq i64 %3, 0
  %test_multi_bb_resolver._Msve.test_multi_bb_resolver.default = select i1 %.not6, ptr @test_multi_bb_resolver.default, ptr @test_multi_bb_resolver._Msve
  br label %common.ret
}

define i32 @bar._MmopsMsve2() #4 {
; CHECK-LABEL: define i32 @bar._MmopsMsve2(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR4:[0-9]+]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_multi_bb_resolver._Mmops()
;
entry:
  %call = tail call i32 @test_multi_bb_resolver()
  ret i32 %call
}

define i32 @bar._Mmops() #3 {
; CHECK-LABEL: define i32 @bar._Mmops(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR3:[0-9]+]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_multi_bb_resolver._Mmops()
;
entry:
  %call = tail call i32 @test_multi_bb_resolver()
  ret i32 %call
}

define i32 @bar._Msve() #1 {
; CHECK-LABEL: define i32 @bar._Msve(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR1]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_multi_bb_resolver()
;
entry:
  %call = tail call i32 @test_multi_bb_resolver()
  ret i32 %call
}

define i32 @bar.default() #0 {
; CHECK-LABEL: define i32 @bar.default(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_multi_bb_resolver.default()
;
entry:
  %call = tail call i32 @test_multi_bb_resolver()
  ret i32 %call
}

declare i32 @test_caller_feats_not_implied._Mmops() #3

declare i32 @test_caller_feats_not_implied._Msme() #5

declare i32 @test_caller_feats_not_implied._Msve() #1

declare i32 @test_caller_feats_not_implied.default() #0

define weak_odr ptr @test_caller_feats_not_implied.resolver() #0 comdat {
; CHECK-LABEL: define weak_odr ptr @test_caller_feats_not_implied.resolver(
; CHECK-SAME: ) #[[ATTR0]] comdat {
resolver_entry:
  tail call void @__init_cpu_features_resolver()
  %0 = load i64, ptr @__aarch64_cpu_features, align 8
  %1 = and i64 %0, 576460752303423488
  %.not = icmp eq i64 %1, 0
  br i1 %.not, label %resolver_else, label %common.ret

common.ret:                                       ; preds = %resolver_else2, %resolver_else, %resolver_entry
  %common.ret.op = phi ptr [ @test_caller_feats_not_implied._Mmops, %resolver_entry ], [ @test_caller_feats_not_implied._Msme, %resolver_else ], [ %test_caller_feats_not_implied._Msve.test_caller_feats_not_implied.default, %resolver_else2 ]
  ret ptr %common.ret.op

resolver_else:                                    ; preds = %resolver_entry
  %2 = and i64 %0, 4398046511104
  %.not5 = icmp eq i64 %2, 0
  br i1 %.not5, label %resolver_else2, label %common.ret

resolver_else2:                                   ; preds = %resolver_else
  %3 = and i64 %0, 1073741824
  %.not6 = icmp eq i64 %3, 0
  %test_caller_feats_not_implied._Msve.test_caller_feats_not_implied.default = select i1 %.not6, ptr @test_caller_feats_not_implied.default, ptr @test_caller_feats_not_implied._Msve
  br label %common.ret
}

define i32 @goo._Mmops() #3 {
; CHECK-LABEL: define i32 @goo._Mmops(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_caller_feats_not_implied._Mmops()
;
entry:
  %call = tail call i32 @test_caller_feats_not_implied()
  ret i32 %call
}

define i32 @goo._Msve() #1 {
; CHECK-LABEL: define i32 @goo._Msve(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR1]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_caller_feats_not_implied()
;
entry:
  %call = tail call i32 @test_caller_feats_not_implied()
  ret i32 %call
}

define i32 @goo.default() #0 {
; CHECK-LABEL: define i32 @goo.default(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_caller_feats_not_implied()
;
entry:
  %call = tail call i32 @test_caller_feats_not_implied()
  ret i32 %call
}

declare i32 @test_non_fmv_caller._Maes() #6

declare i32 @test_non_fmv_caller.default() #0

define weak_odr ptr @test_non_fmv_caller.resolver() #0 comdat {
; CHECK-LABEL: define weak_odr ptr @test_non_fmv_caller.resolver(
; CHECK-SAME: ) #[[ATTR0]] comdat {
resolver_entry:
  tail call void @__init_cpu_features_resolver()
  %0 = load i64, ptr @__aarch64_cpu_features, align 8
  %1 = and i64 %0, 32768
  %.not = icmp eq i64 %1, 0
  %test_non_fmv_caller._Maes.test_non_fmv_caller.default = select i1 %.not, ptr @test_non_fmv_caller.default, ptr @test_non_fmv_caller._Maes
  ret ptr %test_non_fmv_caller._Maes.test_non_fmv_caller.default
}

define i32 @baz() #7 {
; CHECK-LABEL: define i32 @baz(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR7:[0-9]+]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_non_fmv_caller._Maes()
;
entry:
  %call = tail call i32 @test_non_fmv_caller()
  ret i32 %call
}

declare i32 @test_priority._Msve2-sha3() #8

declare i32 @test_priority._Mls64Mssbs() #9

declare i32 @test_priority._MflagmMlseMrng() #10

declare i32 @test_priority.default() #0

define weak_odr ptr @test_priority.resolver() #0 comdat {
; CHECK-LABEL: define weak_odr ptr @test_priority.resolver(
; CHECK-SAME: ) #[[ATTR0]] comdat {
resolver_entry:
  tail call void @__init_cpu_features_resolver()
  %0 = load i64, ptr @__aarch64_cpu_features, align 8
  %1 = and i64 %0, 131
  %2 = icmp eq i64 %1, 131
  br i1 %2, label %common.ret, label %resolver_else

common.ret:                                       ; preds = %resolver_else2, %resolver_else, %resolver_entry
  %common.ret.op = phi ptr [ @test_priority._MflagmMlseMrng, %resolver_entry ], [ @test_priority._Mls64Mssbs, %resolver_else ], [ %test_priority._Msve2-sha3.test_priority.default, %resolver_else2 ]
  ret ptr %common.ret.op

resolver_else:                                    ; preds = %resolver_entry
  %3 = and i64 %0, 9570149208162304
  %4 = icmp eq i64 %3, 9570149208162304
  br i1 %4, label %common.ret, label %resolver_else2

resolver_else2:                                   ; preds = %resolver_else
  %5 = and i64 %0, 1099511627776
  %.not = icmp eq i64 %5, 0
  %test_priority._Msve2-sha3.test_priority.default = select i1 %.not, ptr @test_priority.default, ptr @test_priority._Msve2-sha3
  br label %common.ret
}

; FIXME: This is wrong. When generating the resolver the selection algorithm
; orders the function versions according to the number of specified features,
; from highest to lowest. (Note: I am going on a tangent here but in the case
; of a tie, the version with the highest priority feature is preferred. This
; is non deterministic if the highest priority feature is common. For example
; mops+sve vs mops+sve2).
;
; In this example the problem is slightly different. When in IR we can't know
; what were the features before their dependencies got expanded. Therefore
; we can select based on highest priority feature, then second, then third,
; etc... That's what we should be doing in the front-end too if you ask me.
;
define i32 @hoo._MflagmMls64MlseMrngMssbsMsve2-sha3() #11 {
; CHECK-LABEL: define i32 @hoo._MflagmMls64MlseMrngMssbsMsve2-sha3(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR11:[0-9]+]] {
; CHECK:    [[CALL:%.*]] = tail call i32 @test_priority._Mls64Mssbs()
;
entry:
  %call = tail call i32 @test_priority()
  ret i32 %call
}

attributes #0 = { "target-features"="+fmv,+fp-armv8,+neon,+outline-atomics,+v8a" }
attributes #1 = { "target-features"="+fmv,+fp-armv8,+fullfp16,+neon,+outline-atomics,+sve,+v8a" }
attributes #2 = { "target-features"="+fmv,+fp-armv8,+fullfp16,+neon,+outline-atomics,+sve,+sve2,+v8a" }
attributes #3 = { "target-features"="+fmv,+fp-armv8,+mops,+neon,+outline-atomics,+v8a" }
attributes #4 = { "target-features"="+fmv,+fp-armv8,+fullfp16,+mops,+neon,+outline-atomics,+sve,+sve2,+v8a" }
attributes #5 = { "target-features"="+bf16,+fmv,+fp-armv8,+neon,+outline-atomics,+sme,+v8a" }
attributes #6 = { "target-features"="+aes,+fmv,+fp-armv8,+neon,+outline-atomics,+v8a" }
attributes #7 = { "target-features"="+aes,+fp-armv8,+neon,+outline-atomics,+v8a" }
attributes #8 = { "target-features"="+fmv,+fp-armv8,+fullfp16,+neon,+outline-atomics,+sha2,+sha3,+sve,+sve2,+sve2-sha3,+v8a" }
attributes #9 = { "target-features"="+fmv,+fp-armv8,+ls64,+neon,+outline-atomics,+ssbs,+v8a" }
attributes #10 = { "target-features"="+flagm,+fmv,+fp-armv8,+lse,+neon,+outline-atomics,+rand,+v8a" }
attributes #11 = { "target-features"="+flagm,+fmv,+fp-armv8,+fullfp16,+ls64,+lse,+neon,+outline-atomics,+rand,+sha2,+sha3,+ssbs,+sve,+sve2,+sve2-sha3,+v8a" }
