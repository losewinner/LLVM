; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -S -mtriple riscv64 -mattr="+v" -riscv-v-vector-bits-min=256 \
; RUN:   -passes=loop-vectorize -force-tail-folding-style=data-with-evl \
; RUN:   -enable-csa-vectorization | FileCheck %s -check-prefix=EVL
; RUN: opt < %s -S -mtriple riscv64 -mattr="+v" -riscv-v-vector-bits-min=256 \
; RUN:   -passes=loop-vectorize -force-tail-folding-style=none \
; RUN:   -enable-csa-vectorization | FileCheck %s -check-prefix=NO-EVL
; RUN: opt < %s -S -mtriple riscv64 -mattr="+v" -riscv-v-vector-bits-min=256 \
; RUN:   -passes=loop-vectorize -force-tail-folding-style=data \
; RUN:   -enable-csa-vectorization | FileCheck %s -check-prefix=DATA

; This function is generated from the following C/C++ program:
; int simple_csa_int_select(int N, int *data, int a) {
;   int t = -1;
;   for (int i = 0; i < N; i++) {
;     if (a < data[i])
;       t = data[i];
;   }
;   return t; // use t
; }
define i32 @simple_csa_int_select(i32 %N, ptr %data, i64 %a) {
; EVL-LABEL: @simple_csa_int_select(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; EVL-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[A:%.*]], i64 0
; EVL-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[BROADCAST_SPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP6]]
; EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP7]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP8]], align 4
; EVL-NEXT:    [[TMP9:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; EVL-NEXT:    [[TMP10:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP9]]
; EVL-NEXT:    [[TMP11:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP10]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP11]], <vscale x 4 x i1> [[TMP10]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP11]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[TMP12:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP12]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP13:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP14:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP13]])
; EVL-NEXT:    [[TMP15:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP16:%.*]] = icmp eq i32 [[TMP14]], 0
; EVL-NEXT:    [[TMP17:%.*]] = and i1 [[TMP15]], [[TMP16]]
; EVL-NEXT:    [[TMP18:%.*]] = select i1 [[TMP17]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP18]]
; EVL-NEXT:    [[TMP19:%.*]] = icmp sge i32 [[TMP18]], 0
; EVL-NEXT:    [[TMP20:%.*]] = select i1 [[TMP19]], i32 [[CSA_EXTRACT]], i32 -1
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP20]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP21:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[TMP22:%.*]] = sext i32 [[TMP21]] to i64
; EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[A]], [[TMP22]]
; EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP21]], i32 [[T_010]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]
;
; NO-EVL-LABEL: @simple_csa_int_select(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; NO-EVL-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[A:%.*]], i64 0
; NO-EVL-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[BROADCAST_SPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP6]]
; NO-EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP7]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP8]], align 4
; NO-EVL-NEXT:    [[TMP9:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; NO-EVL-NEXT:    [[TMP10:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP9]]
; NO-EVL-NEXT:    [[TMP11:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP10]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP11]], <vscale x 4 x i1> [[TMP10]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP11]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[TMP12:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP12]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP13:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP14:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP13]])
; NO-EVL-NEXT:    [[TMP15:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP16:%.*]] = icmp eq i32 [[TMP14]], 0
; NO-EVL-NEXT:    [[TMP17:%.*]] = and i1 [[TMP15]], [[TMP16]]
; NO-EVL-NEXT:    [[TMP18:%.*]] = select i1 [[TMP17]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP18]]
; NO-EVL-NEXT:    [[TMP19:%.*]] = icmp sge i32 [[TMP18]], 0
; NO-EVL-NEXT:    [[TMP20:%.*]] = select i1 [[TMP19]], i32 [[CSA_EXTRACT]], i32 -1
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP20]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; NO-EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP21:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[TMP22:%.*]] = sext i32 [[TMP21]] to i64
; NO-EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[A]], [[TMP22]]
; NO-EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP21]], i32 [[T_010]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]
;
; DATA-LABEL: @simple_csa_int_select(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; DATA-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[A:%.*]], i64 0
; DATA-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[BROADCAST_SPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP6]]
; DATA-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP7]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP8]], align 4
; DATA-NEXT:    [[TMP9:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; DATA-NEXT:    [[TMP10:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP9]]
; DATA-NEXT:    [[TMP11:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP10]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP11]], <vscale x 4 x i1> [[TMP10]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP11]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[TMP12:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP12]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP13:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP14:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP13]])
; DATA-NEXT:    [[TMP15:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP16:%.*]] = icmp eq i32 [[TMP14]], 0
; DATA-NEXT:    [[TMP17:%.*]] = and i1 [[TMP15]], [[TMP16]]
; DATA-NEXT:    [[TMP18:%.*]] = select i1 [[TMP17]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP18]]
; DATA-NEXT:    [[TMP19:%.*]] = icmp sge i32 [[TMP18]], 0
; DATA-NEXT:    [[TMP20:%.*]] = select i1 [[TMP19]], i32 [[CSA_EXTRACT]], i32 -1
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP20]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; DATA-NEXT:    ret i32 [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP21:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[TMP22:%.*]] = sext i32 [[TMP21]] to i64
; DATA-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[A]], [[TMP22]]
; DATA-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP21]], i32 [[T_010]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]
;
entry:
  %cmp9 = icmp sgt i32 %N, 0
  br i1 %cmp9, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %spec.select.lcssa = phi i32 [ %spec.select, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %t.0.lcssa = phi i32 [ -1, %entry ], [ %spec.select.lcssa, %for.cond.cleanup.loopexit ]
  ret i32 %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %t.010 = phi i32 [ -1, %for.body.preheader ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %data, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %1 = sext i32 %0 to i64
  %cmp1 = icmp slt i64 %a, %1
  %spec.select = select i1 %cmp1, i32 %0, i32 %t.010
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; int simple_csa_int_select(int N, int *data) {
;   int t = -1;
;   for (int i = 0; i < N; i++) {
;     if (i < data[i])
;       t = data[i];
;   }
;   return t; // use t
; }
define i32 @simple_csa_int_select_induction_cmp(i32 %N, ptr %data) {
; EVL-LABEL: @simple_csa_int_select_induction_cmp(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP12]]
; EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; EVL-NEXT:    [[TMP15:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; EVL-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; EVL-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP16]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 4 x i1> [[TMP16]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; EVL-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP18]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP19:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP20:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP19]])
; EVL-NEXT:    [[TMP21:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP22:%.*]] = icmp eq i32 [[TMP20]], 0
; EVL-NEXT:    [[TMP23:%.*]] = and i1 [[TMP21]], [[TMP22]]
; EVL-NEXT:    [[TMP24:%.*]] = select i1 [[TMP23]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP24]]
; EVL-NEXT:    [[TMP25:%.*]] = icmp sge i32 [[TMP24]], 0
; EVL-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], i32 [[CSA_EXTRACT]], i32 -1
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP26]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP27:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[TMP28:%.*]] = sext i32 [[TMP27]] to i64
; EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP28]]
; EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP27]], i32 [[T_010]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP5:![0-9]+]]
;
; NO-EVL-LABEL: @simple_csa_int_select_induction_cmp(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; NO-EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; NO-EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; NO-EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; NO-EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; NO-EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; NO-EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; NO-EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; NO-EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP12]]
; NO-EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; NO-EVL-NEXT:    [[TMP15:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; NO-EVL-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; NO-EVL-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP16]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 4 x i1> [[TMP16]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; NO-EVL-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP18]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP19:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP20:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP19]])
; NO-EVL-NEXT:    [[TMP21:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP22:%.*]] = icmp eq i32 [[TMP20]], 0
; NO-EVL-NEXT:    [[TMP23:%.*]] = and i1 [[TMP21]], [[TMP22]]
; NO-EVL-NEXT:    [[TMP24:%.*]] = select i1 [[TMP23]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP24]]
; NO-EVL-NEXT:    [[TMP25:%.*]] = icmp sge i32 [[TMP24]], 0
; NO-EVL-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], i32 [[CSA_EXTRACT]], i32 -1
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP26]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; NO-EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP27:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[TMP28:%.*]] = sext i32 [[TMP27]] to i64
; NO-EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP28]]
; NO-EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP27]], i32 [[T_010]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP5:![0-9]+]]
;
; DATA-LABEL: @simple_csa_int_select_induction_cmp(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; DATA-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; DATA-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; DATA-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; DATA-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; DATA-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; DATA-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; DATA-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; DATA-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP12]]
; DATA-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; DATA-NEXT:    [[TMP15:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; DATA-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; DATA-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP16]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 4 x i1> [[TMP16]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; DATA-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP18]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP19:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP20:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP19]])
; DATA-NEXT:    [[TMP21:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP22:%.*]] = icmp eq i32 [[TMP20]], 0
; DATA-NEXT:    [[TMP23:%.*]] = and i1 [[TMP21]], [[TMP22]]
; DATA-NEXT:    [[TMP24:%.*]] = select i1 [[TMP23]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP24]]
; DATA-NEXT:    [[TMP25:%.*]] = icmp sge i32 [[TMP24]], 0
; DATA-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], i32 [[CSA_EXTRACT]], i32 -1
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP26]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; DATA-NEXT:    ret i32 [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP27:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[TMP28:%.*]] = sext i32 [[TMP27]] to i64
; DATA-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP28]]
; DATA-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP27]], i32 [[T_010]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP5:![0-9]+]]
;
entry:
  %cmp9 = icmp sgt i32 %N, 0
  br i1 %cmp9, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %spec.select.lcssa = phi i32 [ %spec.select, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %t.0.lcssa = phi i32 [ -1, %entry ], [ %spec.select.lcssa, %for.cond.cleanup.loopexit ]
  ret i32 %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %t.010 = phi i32 [ -1, %for.body.preheader ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %data, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %1 = sext i32 %0 to i64
  %cmp1 = icmp slt i64 %indvars.iv, %1
  %spec.select = select i1 %cmp1, i32 %0, i32 %t.010
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; float simple_csa_float_select(int N, float *data) {
;   float t = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (0.0f < data[i])
;       t = data[i];
;   }
;   return t; // use t
; }
define float @simple_csa_float_select(i32 %N, ptr %data) {
; EVL-LABEL: @simple_csa_float_select(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP8:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP8]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds float, ptr [[DATA:%.*]], i64 [[TMP6]]
; EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds float, ptr [[TMP7]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x float>, ptr [[TMP8]], align 4
; EVL-NEXT:    [[TMP9:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD]], zeroinitializer
; EVL-NEXT:    [[TMP10:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP9]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP10]], <vscale x 4 x i1> [[TMP9]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP10]], <vscale x 4 x float> [[WIDE_LOAD]], <vscale x 4 x float> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP12:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP13:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP12]])
; EVL-NEXT:    [[TMP14:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[TMP13]], 0
; EVL-NEXT:    [[TMP16:%.*]] = and i1 [[TMP14]], [[TMP15]]
; EVL-NEXT:    [[TMP17:%.*]] = select i1 [[TMP16]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL]], i32 [[TMP17]]
; EVL-NEXT:    [[TMP18:%.*]] = icmp sge i32 [[TMP17]], 0
; EVL-NEXT:    [[TMP19:%.*]] = select i1 [[TMP18]], float [[CSA_EXTRACT]], float 1.000000e+00
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_BODY]] ], [ [[TMP19]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; EVL-NEXT:    ret float [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_09:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[T_1]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP20]], 0.000000e+00
; EVL-NEXT:    [[T_1]] = select i1 [[CMP1]], float [[TMP20]], float [[T_09]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]
;
; NO-EVL-LABEL: @simple_csa_float_select(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP8:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP8]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds float, ptr [[DATA:%.*]], i64 [[TMP6]]
; NO-EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds float, ptr [[TMP7]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x float>, ptr [[TMP8]], align 4
; NO-EVL-NEXT:    [[TMP9:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD]], zeroinitializer
; NO-EVL-NEXT:    [[TMP10:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP9]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP10]], <vscale x 4 x i1> [[TMP9]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP10]], <vscale x 4 x float> [[WIDE_LOAD]], <vscale x 4 x float> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP12:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP13:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP12]])
; NO-EVL-NEXT:    [[TMP14:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[TMP13]], 0
; NO-EVL-NEXT:    [[TMP16:%.*]] = and i1 [[TMP14]], [[TMP15]]
; NO-EVL-NEXT:    [[TMP17:%.*]] = select i1 [[TMP16]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL]], i32 [[TMP17]]
; NO-EVL-NEXT:    [[TMP18:%.*]] = icmp sge i32 [[TMP17]], 0
; NO-EVL-NEXT:    [[TMP19:%.*]] = select i1 [[TMP18]], float [[CSA_EXTRACT]], float 1.000000e+00
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_BODY]] ], [ [[TMP19]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; NO-EVL-NEXT:    ret float [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_09:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[T_1]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP20]], 0.000000e+00
; NO-EVL-NEXT:    [[T_1]] = select i1 [[CMP1]], float [[TMP20]], float [[T_09]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]
;
; DATA-LABEL: @simple_csa_float_select(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP8:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP8]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP7:%.*]] = getelementptr inbounds float, ptr [[DATA:%.*]], i64 [[TMP6]]
; DATA-NEXT:    [[TMP8:%.*]] = getelementptr inbounds float, ptr [[TMP7]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x float>, ptr [[TMP8]], align 4
; DATA-NEXT:    [[TMP9:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD]], zeroinitializer
; DATA-NEXT:    [[TMP10:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP9]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP10]], <vscale x 4 x i1> [[TMP9]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP10]], <vscale x 4 x float> [[WIDE_LOAD]], <vscale x 4 x float> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP12:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP13:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP12]])
; DATA-NEXT:    [[TMP14:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[TMP13]], 0
; DATA-NEXT:    [[TMP16:%.*]] = and i1 [[TMP14]], [[TMP15]]
; DATA-NEXT:    [[TMP17:%.*]] = select i1 [[TMP16]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL]], i32 [[TMP17]]
; DATA-NEXT:    [[TMP18:%.*]] = icmp sge i32 [[TMP17]], 0
; DATA-NEXT:    [[TMP19:%.*]] = select i1 [[TMP18]], float [[CSA_EXTRACT]], float 1.000000e+00
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_BODY]] ], [ [[TMP19]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; DATA-NEXT:    ret float [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_09:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[T_1]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP20]], 0.000000e+00
; DATA-NEXT:    [[T_1]] = select i1 [[CMP1]], float [[TMP20]], float [[T_09]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]
;
entry:
  %cmp8 = icmp sgt i32 %N, 0
  br i1 %cmp8, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %t.0.lcssa = phi float [ 1.000000e+00, %entry ], [ %t.1, %for.body ]
  ret float %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %t.09 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.1, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %data, i64 %indvars.iv
  %0 = load float, ptr %arrayidx, align 4
  %cmp1 = fcmp ogt float %0, 0.000000e+00
  %t.1 = select i1 %cmp1, float %0, float %t.09
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; int simple_csa_int(int N, bool *cond, int *data) {
;   int t = -1;
;   for (int i = 0; i < N; i++) {
;     if (cond[i])
;       t = data[i];
;   }
;   return t; // use t
; }
define i32 @simple_csa_int(i32 %N, ptr %cond, ptr %data) {
; EVL-LABEL: @simple_csa_int(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP6:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP6]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_07:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_1]] = phi i32 [ [[TMP1]], [[IF_THEN]] ], [ [[T_07]], [[FOR_BODY]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @simple_csa_int(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP6:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP6]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_07:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_1]] = phi i32 [ [[TMP1]], [[IF_THEN]] ], [ [[T_07]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @simple_csa_int(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP6:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP6]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; DATA-NEXT:    ret i32 [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_07:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_1]] = phi i32 [ [[TMP1]], [[IF_THEN]] ], [ [[T_07]], [[FOR_BODY]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp6 = icmp sgt i32 %N, 0
  br i1 %cmp6, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %entry
  %t.0.lcssa = phi i32 [ -1, %entry ], [ %t.1, %for.inc ]
  ret i32 %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %t.07 = phi i32 [ -1, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds i32, ptr %data, i64 %indvars.iv
  %1 = load i32, ptr %arrayidx2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %t.1 = phi i32 [ %1, %if.then ], [ %t.07, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; float simple_csa_float(int N, bool *cond, float *data) {
;   float t = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (cond[i])
;       t = data[i];
;   }
;   return t; // use t
; }
define float @simple_csa_float(i32 %N, ptr %cond, ptr %data) {
; EVL-LABEL: @simple_csa_float(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP6:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP6]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; EVL-NEXT:    ret float [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_07:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_1]] = phi float [ [[TMP1]], [[IF_THEN]] ], [ [[T_07]], [[FOR_BODY]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @simple_csa_float(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP6:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP6]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; NO-EVL-NEXT:    ret float [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_07:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_1]] = phi float [ [[TMP1]], [[IF_THEN]] ], [ [[T_07]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @simple_csa_float(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP6:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP6]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; DATA-NEXT:    ret float [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_07:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_1]] = phi float [ [[TMP1]], [[IF_THEN]] ], [ [[T_07]], [[FOR_BODY]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp6 = icmp sgt i32 %N, 0
  br i1 %cmp6, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %entry
  %t.0.lcssa = phi float [ 1.000000e+00, %entry ], [ %t.1, %for.inc ]
  ret float %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %t.07 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds float, ptr %data, i64 %indvars.iv
  %1 = load float, ptr %arrayidx2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %t.1 = phi float [ %1, %if.then ], [ %t.07, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; int csa_in_series_int_select(int N, int *data0, int *data1, int a) {
;   int t = -1;
;   int s = -1;
;   for (int i = 0; i < N; i++) {
;     if (a < data0[i])
;       t = data0[i];
;     if (a < data1[i])
;       s = data1[i];
;   }
;   return t | s; // use t and s
; }
define i32 @csa_in_series_int_select(i32 %N, ptr %data0, ptr %data1, i64 %a) {
; EVL-LABEL: @csa_in_series_int_select(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; EVL-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[A:%.*]], i64 0
; EVL-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[BROADCAST_SPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[TMP6]]
; EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP7]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP8]], align 4
; EVL-NEXT:    [[TMP9:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; EVL-NEXT:    [[TMP10:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP9]]
; EVL-NEXT:    [[TMP11:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP10]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP11]], <vscale x 4 x i1> [[TMP10]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP11]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI2]]
; EVL-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[TMP6]]
; EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[TMP12]], i32 0
; EVL-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x i32>, ptr [[TMP13]], align 4
; EVL-NEXT:    [[TMP14:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD3]] to <vscale x 4 x i64>
; EVL-NEXT:    [[TMP15:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP14]]
; EVL-NEXT:    [[TMP16:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP15]])
; EVL-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP16]], <vscale x 4 x i1> [[TMP15]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP16]], <vscale x 4 x i32> [[WIDE_LOAD3]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[TMP17:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP17]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP8:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP18:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP19:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP18]])
; EVL-NEXT:    [[TMP20:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; EVL-NEXT:    [[TMP21:%.*]] = icmp eq i32 [[TMP19]], 0
; EVL-NEXT:    [[TMP22:%.*]] = and i1 [[TMP20]], [[TMP21]]
; EVL-NEXT:    [[TMP23:%.*]] = select i1 [[TMP22]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL5]], i32 [[TMP23]]
; EVL-NEXT:    [[TMP24:%.*]] = icmp sge i32 [[TMP23]], 0
; EVL-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 [[CSA_EXTRACT7]], i32 -1
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP26:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP27:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP26]])
; EVL-NEXT:    [[TMP28:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP29:%.*]] = icmp eq i32 [[TMP27]], 0
; EVL-NEXT:    [[TMP30:%.*]] = and i1 [[TMP28]], [[TMP29]]
; EVL-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP31]]
; EVL-NEXT:    [[TMP32:%.*]] = icmp sge i32 [[TMP31]], 0
; EVL-NEXT:    [[TMP33:%.*]] = select i1 [[TMP32]], i32 [[CSA_EXTRACT]], i32 -1
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP33]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP25]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    [[TMP34:%.*]] = or i32 [[S_1_LCSSA]], [[SPEC_SELECT_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP34]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ -1, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret i32 [[OR]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[S_023:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP35:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[TMP36:%.*]] = sext i32 [[TMP35]] to i64
; EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[A]], [[TMP36]]
; EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP35]], i32 [[T_022]]
; EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP37:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; EVL-NEXT:    [[TMP38:%.*]] = sext i32 [[TMP37]] to i64
; EVL-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[A]], [[TMP38]]
; EVL-NEXT:    [[S_1]] = select i1 [[CMP6]], i32 [[TMP37]], i32 [[S_023]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP9:![0-9]+]]
;
; NO-EVL-LABEL: @csa_in_series_int_select(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; NO-EVL-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[A:%.*]], i64 0
; NO-EVL-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[BROADCAST_SPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[TMP6]]
; NO-EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP7]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP8]], align 4
; NO-EVL-NEXT:    [[TMP9:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; NO-EVL-NEXT:    [[TMP10:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP9]]
; NO-EVL-NEXT:    [[TMP11:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP10]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP11]], <vscale x 4 x i1> [[TMP10]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP11]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI2]]
; NO-EVL-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[TMP6]]
; NO-EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[TMP12]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x i32>, ptr [[TMP13]], align 4
; NO-EVL-NEXT:    [[TMP14:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD3]] to <vscale x 4 x i64>
; NO-EVL-NEXT:    [[TMP15:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP14]]
; NO-EVL-NEXT:    [[TMP16:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP15]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP16]], <vscale x 4 x i1> [[TMP15]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP16]], <vscale x 4 x i32> [[WIDE_LOAD3]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[TMP17:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP17]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP8:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP18:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP19:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP18]])
; NO-EVL-NEXT:    [[TMP20:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; NO-EVL-NEXT:    [[TMP21:%.*]] = icmp eq i32 [[TMP19]], 0
; NO-EVL-NEXT:    [[TMP22:%.*]] = and i1 [[TMP20]], [[TMP21]]
; NO-EVL-NEXT:    [[TMP23:%.*]] = select i1 [[TMP22]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL5]], i32 [[TMP23]]
; NO-EVL-NEXT:    [[TMP24:%.*]] = icmp sge i32 [[TMP23]], 0
; NO-EVL-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 [[CSA_EXTRACT7]], i32 -1
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP26:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP27:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP26]])
; NO-EVL-NEXT:    [[TMP28:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP29:%.*]] = icmp eq i32 [[TMP27]], 0
; NO-EVL-NEXT:    [[TMP30:%.*]] = and i1 [[TMP28]], [[TMP29]]
; NO-EVL-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP31]]
; NO-EVL-NEXT:    [[TMP32:%.*]] = icmp sge i32 [[TMP31]], 0
; NO-EVL-NEXT:    [[TMP33:%.*]] = select i1 [[TMP32]], i32 [[CSA_EXTRACT]], i32 -1
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP33]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP25]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    [[TMP34:%.*]] = or i32 [[S_1_LCSSA]], [[SPEC_SELECT_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP34]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ -1, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[OR]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[S_023:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP35:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[TMP36:%.*]] = sext i32 [[TMP35]] to i64
; NO-EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[A]], [[TMP36]]
; NO-EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP35]], i32 [[T_022]]
; NO-EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP37:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; NO-EVL-NEXT:    [[TMP38:%.*]] = sext i32 [[TMP37]] to i64
; NO-EVL-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[A]], [[TMP38]]
; NO-EVL-NEXT:    [[S_1]] = select i1 [[CMP6]], i32 [[TMP37]], i32 [[S_023]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP9:![0-9]+]]
;
; DATA-LABEL: @csa_in_series_int_select(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; DATA-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[A:%.*]], i64 0
; DATA-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[BROADCAST_SPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[TMP6]]
; DATA-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP7]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP8]], align 4
; DATA-NEXT:    [[TMP9:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; DATA-NEXT:    [[TMP10:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP9]]
; DATA-NEXT:    [[TMP11:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP10]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP11]], <vscale x 4 x i1> [[TMP10]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP11]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI2]]
; DATA-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[TMP6]]
; DATA-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[TMP12]], i32 0
; DATA-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x i32>, ptr [[TMP13]], align 4
; DATA-NEXT:    [[TMP14:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD3]] to <vscale x 4 x i64>
; DATA-NEXT:    [[TMP15:%.*]] = icmp slt <vscale x 4 x i64> [[BROADCAST_SPLAT]], [[TMP14]]
; DATA-NEXT:    [[TMP16:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP15]])
; DATA-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP16]], <vscale x 4 x i1> [[TMP15]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP16]], <vscale x 4 x i32> [[WIDE_LOAD3]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[TMP17:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP17]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP8:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP18:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP19:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP18]])
; DATA-NEXT:    [[TMP20:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; DATA-NEXT:    [[TMP21:%.*]] = icmp eq i32 [[TMP19]], 0
; DATA-NEXT:    [[TMP22:%.*]] = and i1 [[TMP20]], [[TMP21]]
; DATA-NEXT:    [[TMP23:%.*]] = select i1 [[TMP22]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL5]], i32 [[TMP23]]
; DATA-NEXT:    [[TMP24:%.*]] = icmp sge i32 [[TMP23]], 0
; DATA-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 [[CSA_EXTRACT7]], i32 -1
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP26:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP27:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP26]])
; DATA-NEXT:    [[TMP28:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP29:%.*]] = icmp eq i32 [[TMP27]], 0
; DATA-NEXT:    [[TMP30:%.*]] = and i1 [[TMP28]], [[TMP29]]
; DATA-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP31]]
; DATA-NEXT:    [[TMP32:%.*]] = icmp sge i32 [[TMP31]], 0
; DATA-NEXT:    [[TMP33:%.*]] = select i1 [[TMP32]], i32 [[CSA_EXTRACT]], i32 -1
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP33]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP25]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    [[TMP34:%.*]] = or i32 [[S_1_LCSSA]], [[SPEC_SELECT_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP34]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ -1, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret i32 [[OR]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[S_023:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP35:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[TMP36:%.*]] = sext i32 [[TMP35]] to i64
; DATA-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[A]], [[TMP36]]
; DATA-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP35]], i32 [[T_022]]
; DATA-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP37:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; DATA-NEXT:    [[TMP38:%.*]] = sext i32 [[TMP37]] to i64
; DATA-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[A]], [[TMP38]]
; DATA-NEXT:    [[S_1]] = select i1 [[CMP6]], i32 [[TMP37]], i32 [[S_023]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP9:![0-9]+]]
;
entry:
  %cmp21 = icmp sgt i32 %N, 0
  br i1 %cmp21, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %0 = or i32 %s.1, %spec.select
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %or = phi i32 [ %0, %for.cond.cleanup.loopexit ], [ -1, %entry ]
  ret i32 %or

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %s.023 = phi i32 [ -1, %for.body.preheader ], [ %s.1, %for.body ]
  %t.022 = phi i32 [ -1, %for.body.preheader ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %data0, i64 %indvars.iv
  %1 = load i32, ptr %arrayidx, align 4
  %2 = sext i32 %1 to i64
  %cmp1 = icmp slt i64 %a, %2
  %spec.select = select i1 %cmp1, i32 %1, i32 %t.022
  %arrayidx5 = getelementptr inbounds i32, ptr %data1, i64 %indvars.iv
  %3 = load i32, ptr %arrayidx5, align 4
  %4 = sext i32 %3 to i64
  %cmp6 = icmp slt i64 %a, %4
  %s.1 = select i1 %cmp6, i32 %3, i32 %s.023
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; int csa_in_series_int_select(int N, int *data0, int *data1) {
;   int t = -1;
;   int s = -1;
;   for (int i = 0; i < N; i++) {
;     if (a < data0[i])
;       t = data0[i];
;     if (a < data1[i])
;       s = data1[i];
;   }
;   return t | s; // use t and s
; }
define i32 @csa_in_series_int_select_induction_cmp(i32 %N, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_in_series_int_select_induction_cmp(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[TMP12]]
; EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; EVL-NEXT:    [[TMP15:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; EVL-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; EVL-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP16]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 4 x i1> [[TMP16]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI2]]
; EVL-NEXT:    [[TMP18:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[TMP12]]
; EVL-NEXT:    [[TMP19:%.*]] = getelementptr inbounds i32, ptr [[TMP18]], i32 0
; EVL-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x i32>, ptr [[TMP19]], align 4
; EVL-NEXT:    [[TMP20:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD3]] to <vscale x 4 x i64>
; EVL-NEXT:    [[TMP21:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP20]]
; EVL-NEXT:    [[TMP22:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP21]])
; EVL-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP22]], <vscale x 4 x i1> [[TMP21]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP22]], <vscale x 4 x i32> [[WIDE_LOAD3]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; EVL-NEXT:    [[TMP23:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP23]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP10:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP24:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP25:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP24]])
; EVL-NEXT:    [[TMP26:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; EVL-NEXT:    [[TMP27:%.*]] = icmp eq i32 [[TMP25]], 0
; EVL-NEXT:    [[TMP28:%.*]] = and i1 [[TMP26]], [[TMP27]]
; EVL-NEXT:    [[TMP29:%.*]] = select i1 [[TMP28]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL5]], i32 [[TMP29]]
; EVL-NEXT:    [[TMP30:%.*]] = icmp sge i32 [[TMP29]], 0
; EVL-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], i32 [[CSA_EXTRACT7]], i32 -1
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP32:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP33:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP32]])
; EVL-NEXT:    [[TMP34:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP35:%.*]] = icmp eq i32 [[TMP33]], 0
; EVL-NEXT:    [[TMP36:%.*]] = and i1 [[TMP34]], [[TMP35]]
; EVL-NEXT:    [[TMP37:%.*]] = select i1 [[TMP36]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP37]]
; EVL-NEXT:    [[TMP38:%.*]] = icmp sge i32 [[TMP37]], 0
; EVL-NEXT:    [[TMP39:%.*]] = select i1 [[TMP38]], i32 [[CSA_EXTRACT]], i32 -1
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP39]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP31]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    [[TMP40:%.*]] = or i32 [[S_1_LCSSA]], [[SPEC_SELECT_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP40]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ -1, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret i32 [[OR]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[S_023:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP41:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[TMP42:%.*]] = sext i32 [[TMP41]] to i64
; EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP42]]
; EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP41]], i32 [[T_022]]
; EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP43:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; EVL-NEXT:    [[TMP44:%.*]] = sext i32 [[TMP43]] to i64
; EVL-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP44]]
; EVL-NEXT:    [[S_1]] = select i1 [[CMP6]], i32 [[TMP43]], i32 [[S_023]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]
;
; NO-EVL-LABEL: @csa_in_series_int_select_induction_cmp(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; NO-EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; NO-EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; NO-EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; NO-EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; NO-EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; NO-EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; NO-EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; NO-EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[TMP12]]
; NO-EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; NO-EVL-NEXT:    [[TMP15:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; NO-EVL-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; NO-EVL-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP16]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 4 x i1> [[TMP16]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI2]]
; NO-EVL-NEXT:    [[TMP18:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[TMP12]]
; NO-EVL-NEXT:    [[TMP19:%.*]] = getelementptr inbounds i32, ptr [[TMP18]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x i32>, ptr [[TMP19]], align 4
; NO-EVL-NEXT:    [[TMP20:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD3]] to <vscale x 4 x i64>
; NO-EVL-NEXT:    [[TMP21:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP20]]
; NO-EVL-NEXT:    [[TMP22:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP21]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP22]], <vscale x 4 x i1> [[TMP21]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP22]], <vscale x 4 x i32> [[WIDE_LOAD3]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; NO-EVL-NEXT:    [[TMP23:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP23]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP10:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP24:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP25:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP24]])
; NO-EVL-NEXT:    [[TMP26:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; NO-EVL-NEXT:    [[TMP27:%.*]] = icmp eq i32 [[TMP25]], 0
; NO-EVL-NEXT:    [[TMP28:%.*]] = and i1 [[TMP26]], [[TMP27]]
; NO-EVL-NEXT:    [[TMP29:%.*]] = select i1 [[TMP28]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL5]], i32 [[TMP29]]
; NO-EVL-NEXT:    [[TMP30:%.*]] = icmp sge i32 [[TMP29]], 0
; NO-EVL-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], i32 [[CSA_EXTRACT7]], i32 -1
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP32:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP33:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP32]])
; NO-EVL-NEXT:    [[TMP34:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP35:%.*]] = icmp eq i32 [[TMP33]], 0
; NO-EVL-NEXT:    [[TMP36:%.*]] = and i1 [[TMP34]], [[TMP35]]
; NO-EVL-NEXT:    [[TMP37:%.*]] = select i1 [[TMP36]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP37]]
; NO-EVL-NEXT:    [[TMP38:%.*]] = icmp sge i32 [[TMP37]], 0
; NO-EVL-NEXT:    [[TMP39:%.*]] = select i1 [[TMP38]], i32 [[CSA_EXTRACT]], i32 -1
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP39]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP31]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    [[TMP40:%.*]] = or i32 [[S_1_LCSSA]], [[SPEC_SELECT_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP40]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ -1, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[OR]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[S_023:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP41:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[TMP42:%.*]] = sext i32 [[TMP41]] to i64
; NO-EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP42]]
; NO-EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP41]], i32 [[T_022]]
; NO-EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP43:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; NO-EVL-NEXT:    [[TMP44:%.*]] = sext i32 [[TMP43]] to i64
; NO-EVL-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP44]]
; NO-EVL-NEXT:    [[S_1]] = select i1 [[CMP6]], i32 [[TMP43]], i32 [[S_023]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]
;
; DATA-LABEL: @csa_in_series_int_select_induction_cmp(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; DATA-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; DATA-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; DATA-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; DATA-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; DATA-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; DATA-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; DATA-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; DATA-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[TMP12]]
; DATA-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; DATA-NEXT:    [[TMP15:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; DATA-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; DATA-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP16]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 4 x i1> [[TMP16]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI2]]
; DATA-NEXT:    [[TMP18:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[TMP12]]
; DATA-NEXT:    [[TMP19:%.*]] = getelementptr inbounds i32, ptr [[TMP18]], i32 0
; DATA-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x i32>, ptr [[TMP19]], align 4
; DATA-NEXT:    [[TMP20:%.*]] = sext <vscale x 4 x i32> [[WIDE_LOAD3]] to <vscale x 4 x i64>
; DATA-NEXT:    [[TMP21:%.*]] = icmp slt <vscale x 4 x i64> [[VEC_IND]], [[TMP20]]
; DATA-NEXT:    [[TMP22:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP21]])
; DATA-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP22]], <vscale x 4 x i1> [[TMP21]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP22]], <vscale x 4 x i32> [[WIDE_LOAD3]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; DATA-NEXT:    [[TMP23:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP23]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP10:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP24:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP25:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP24]])
; DATA-NEXT:    [[TMP26:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; DATA-NEXT:    [[TMP27:%.*]] = icmp eq i32 [[TMP25]], 0
; DATA-NEXT:    [[TMP28:%.*]] = and i1 [[TMP26]], [[TMP27]]
; DATA-NEXT:    [[TMP29:%.*]] = select i1 [[TMP28]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL5]], i32 [[TMP29]]
; DATA-NEXT:    [[TMP30:%.*]] = icmp sge i32 [[TMP29]], 0
; DATA-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], i32 [[CSA_EXTRACT7]], i32 -1
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP32:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP33:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP32]])
; DATA-NEXT:    [[TMP34:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP35:%.*]] = icmp eq i32 [[TMP33]], 0
; DATA-NEXT:    [[TMP36:%.*]] = and i1 [[TMP34]], [[TMP35]]
; DATA-NEXT:    [[TMP37:%.*]] = select i1 [[TMP36]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP37]]
; DATA-NEXT:    [[TMP38:%.*]] = icmp sge i32 [[TMP37]], 0
; DATA-NEXT:    [[TMP39:%.*]] = select i1 [[TMP38]], i32 [[CSA_EXTRACT]], i32 -1
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP39]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP31]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    [[TMP40:%.*]] = or i32 [[S_1_LCSSA]], [[SPEC_SELECT_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP40]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ -1, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret i32 [[OR]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[S_023:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP41:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[TMP42:%.*]] = sext i32 [[TMP41]] to i64
; DATA-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP42]]
; DATA-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], i32 [[TMP41]], i32 [[T_022]]
; DATA-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP43:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; DATA-NEXT:    [[TMP44:%.*]] = sext i32 [[TMP43]] to i64
; DATA-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP44]]
; DATA-NEXT:    [[S_1]] = select i1 [[CMP6]], i32 [[TMP43]], i32 [[S_023]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]
;
entry:
  %cmp21 = icmp sgt i32 %N, 0
  br i1 %cmp21, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %0 = or i32 %s.1, %spec.select
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %or = phi i32 [ %0, %for.cond.cleanup.loopexit ], [ -1, %entry ]
  ret i32 %or

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %s.023 = phi i32 [ -1, %for.body.preheader ], [ %s.1, %for.body ]
  %t.022 = phi i32 [ -1, %for.body.preheader ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %data0, i64 %indvars.iv
  %1 = load i32, ptr %arrayidx, align 4
  %2 = sext i32 %1 to i64
  %cmp1 = icmp slt i64 %indvars.iv, %2
  %spec.select = select i1 %cmp1, i32 %1, i32 %t.022
  %arrayidx5 = getelementptr inbounds i32, ptr %data1, i64 %indvars.iv
  %3 = load i32, ptr %arrayidx5, align 4
  %4 = sext i32 %3 to i64
  %cmp6 = icmp slt i64 %indvars.iv, %4
  %s.1 = select i1 %cmp6, i32 %3, i32 %s.023
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; float csa_in_series_float_select(int N, float *data0,
;                           float *data1) {
;   float t = 1.0f;
;   float s = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (0.0f < data0[i])
;       t = data0[i];
;     if (0.0f <data1[i])
;       s = data1[i];
;   }
;   return t + s; // use t and s
; }
define float @csa_in_series_float_select(i32 %N, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_in_series_float_select(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP19:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP19]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[TMP6]]
; EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds float, ptr [[TMP7]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x float>, ptr [[TMP8]], align 4
; EVL-NEXT:    [[TMP9:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD]], zeroinitializer
; EVL-NEXT:    [[TMP10:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP9]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP10]], <vscale x 4 x i1> [[TMP9]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP10]], <vscale x 4 x float> [[WIDE_LOAD]], <vscale x 4 x float> [[CSA_DATA_PHI2]]
; EVL-NEXT:    [[TMP11:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[TMP6]]
; EVL-NEXT:    [[TMP12:%.*]] = getelementptr inbounds float, ptr [[TMP11]], i32 0
; EVL-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x float>, ptr [[TMP12]], align 4
; EVL-NEXT:    [[TMP13:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD3]], zeroinitializer
; EVL-NEXT:    [[TMP14:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP13]])
; EVL-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP14]], <vscale x 4 x i1> [[TMP13]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP14]], <vscale x 4 x float> [[WIDE_LOAD3]], <vscale x 4 x float> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[TMP15:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP15]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP16:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP17:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP16]])
; EVL-NEXT:    [[TMP18:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; EVL-NEXT:    [[TMP19:%.*]] = icmp eq i32 [[TMP17]], 0
; EVL-NEXT:    [[TMP20:%.*]] = and i1 [[TMP18]], [[TMP19]]
; EVL-NEXT:    [[TMP21:%.*]] = select i1 [[TMP20]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL5]], i32 [[TMP21]]
; EVL-NEXT:    [[TMP22:%.*]] = icmp sge i32 [[TMP21]], 0
; EVL-NEXT:    [[TMP23:%.*]] = select i1 [[TMP22]], float [[CSA_EXTRACT7]], float 1.000000e+00
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP24:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP25:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP24]])
; EVL-NEXT:    [[TMP26:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP27:%.*]] = icmp eq i32 [[TMP25]], 0
; EVL-NEXT:    [[TMP28:%.*]] = and i1 [[TMP26]], [[TMP27]]
; EVL-NEXT:    [[TMP29:%.*]] = select i1 [[TMP28]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL]], i32 [[TMP29]]
; EVL-NEXT:    [[TMP30:%.*]] = icmp sge i32 [[TMP29]], 0
; EVL-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], float [[CSA_EXTRACT]], float 1.000000e+00
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_BODY]] ], [ [[TMP31]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP23]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    [[TMP32:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[ADD:%.*]] = phi float [ [[TMP32]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret float [[ADD]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[S_021:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_020:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[T_1]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA0]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP33:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP33]], 0.000000e+00
; EVL-NEXT:    [[T_1]] = select i1 [[CMP1]], float [[TMP33]], float [[T_020]]
; EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds float, ptr [[DATA1]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP34:%.*]] = load float, ptr [[ARRAYIDX5]], align 4
; EVL-NEXT:    [[CMP6:%.*]] = fcmp ogt float [[TMP34]], 0.000000e+00
; EVL-NEXT:    [[S_1]] = select i1 [[CMP6]], float [[TMP34]], float [[S_021]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP13:![0-9]+]]
;
; NO-EVL-LABEL: @csa_in_series_float_select(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP19:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP19]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[TMP6]]
; NO-EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds float, ptr [[TMP7]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x float>, ptr [[TMP8]], align 4
; NO-EVL-NEXT:    [[TMP9:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD]], zeroinitializer
; NO-EVL-NEXT:    [[TMP10:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP9]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP10]], <vscale x 4 x i1> [[TMP9]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP10]], <vscale x 4 x float> [[WIDE_LOAD]], <vscale x 4 x float> [[CSA_DATA_PHI2]]
; NO-EVL-NEXT:    [[TMP11:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[TMP6]]
; NO-EVL-NEXT:    [[TMP12:%.*]] = getelementptr inbounds float, ptr [[TMP11]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x float>, ptr [[TMP12]], align 4
; NO-EVL-NEXT:    [[TMP13:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD3]], zeroinitializer
; NO-EVL-NEXT:    [[TMP14:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP13]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP14]], <vscale x 4 x i1> [[TMP13]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP14]], <vscale x 4 x float> [[WIDE_LOAD3]], <vscale x 4 x float> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[TMP15:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP15]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP16:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP17:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP16]])
; NO-EVL-NEXT:    [[TMP18:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; NO-EVL-NEXT:    [[TMP19:%.*]] = icmp eq i32 [[TMP17]], 0
; NO-EVL-NEXT:    [[TMP20:%.*]] = and i1 [[TMP18]], [[TMP19]]
; NO-EVL-NEXT:    [[TMP21:%.*]] = select i1 [[TMP20]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL5]], i32 [[TMP21]]
; NO-EVL-NEXT:    [[TMP22:%.*]] = icmp sge i32 [[TMP21]], 0
; NO-EVL-NEXT:    [[TMP23:%.*]] = select i1 [[TMP22]], float [[CSA_EXTRACT7]], float 1.000000e+00
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP24:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP25:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP24]])
; NO-EVL-NEXT:    [[TMP26:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP27:%.*]] = icmp eq i32 [[TMP25]], 0
; NO-EVL-NEXT:    [[TMP28:%.*]] = and i1 [[TMP26]], [[TMP27]]
; NO-EVL-NEXT:    [[TMP29:%.*]] = select i1 [[TMP28]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL]], i32 [[TMP29]]
; NO-EVL-NEXT:    [[TMP30:%.*]] = icmp sge i32 [[TMP29]], 0
; NO-EVL-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], float [[CSA_EXTRACT]], float 1.000000e+00
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_BODY]] ], [ [[TMP31]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP23]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    [[TMP32:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[ADD:%.*]] = phi float [ [[TMP32]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret float [[ADD]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[S_021:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_020:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[T_1]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA0]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP33:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP33]], 0.000000e+00
; NO-EVL-NEXT:    [[T_1]] = select i1 [[CMP1]], float [[TMP33]], float [[T_020]]
; NO-EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds float, ptr [[DATA1]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP34:%.*]] = load float, ptr [[ARRAYIDX5]], align 4
; NO-EVL-NEXT:    [[CMP6:%.*]] = fcmp ogt float [[TMP34]], 0.000000e+00
; NO-EVL-NEXT:    [[S_1]] = select i1 [[CMP6]], float [[TMP34]], float [[S_021]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP13:![0-9]+]]
;
; DATA-LABEL: @csa_in_series_float_select(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP19:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP19]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL4:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI1:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL5:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI2:%.*]] = phi <vscale x 4 x float> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP7:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[TMP6]]
; DATA-NEXT:    [[TMP8:%.*]] = getelementptr inbounds float, ptr [[TMP7]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x float>, ptr [[TMP8]], align 4
; DATA-NEXT:    [[TMP9:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD]], zeroinitializer
; DATA-NEXT:    [[TMP10:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP9]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP10]], <vscale x 4 x i1> [[TMP9]], <vscale x 4 x i1> [[CSA_MASK_PHI1]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP10]], <vscale x 4 x float> [[WIDE_LOAD]], <vscale x 4 x float> [[CSA_DATA_PHI2]]
; DATA-NEXT:    [[TMP11:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[TMP6]]
; DATA-NEXT:    [[TMP12:%.*]] = getelementptr inbounds float, ptr [[TMP11]], i32 0
; DATA-NEXT:    [[WIDE_LOAD3:%.*]] = load <vscale x 4 x float>, ptr [[TMP12]], align 4
; DATA-NEXT:    [[TMP13:%.*]] = fcmp ogt <vscale x 4 x float> [[WIDE_LOAD3]], zeroinitializer
; DATA-NEXT:    [[TMP14:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP13]])
; DATA-NEXT:    [[CSA_MASK_SEL4]] = select i1 [[TMP14]], <vscale x 4 x i1> [[TMP13]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL5]] = select i1 [[TMP14]], <vscale x 4 x float> [[WIDE_LOAD3]], <vscale x 4 x float> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[TMP15:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP15]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP6:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP16:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL4]], <vscale x 4 x i32> [[CSA_STEP6]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP17:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP16]])
; DATA-NEXT:    [[TMP18:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL4]], i64 0
; DATA-NEXT:    [[TMP19:%.*]] = icmp eq i32 [[TMP17]], 0
; DATA-NEXT:    [[TMP20:%.*]] = and i1 [[TMP18]], [[TMP19]]
; DATA-NEXT:    [[TMP21:%.*]] = select i1 [[TMP20]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT7:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL5]], i32 [[TMP21]]
; DATA-NEXT:    [[TMP22:%.*]] = icmp sge i32 [[TMP21]], 0
; DATA-NEXT:    [[TMP23:%.*]] = select i1 [[TMP22]], float [[CSA_EXTRACT7]], float 1.000000e+00
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP24:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP25:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP24]])
; DATA-NEXT:    [[TMP26:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP27:%.*]] = icmp eq i32 [[TMP25]], 0
; DATA-NEXT:    [[TMP28:%.*]] = and i1 [[TMP26]], [[TMP27]]
; DATA-NEXT:    [[TMP29:%.*]] = select i1 [[TMP28]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x float> [[CSA_DATA_SEL]], i32 [[TMP29]]
; DATA-NEXT:    [[TMP30:%.*]] = icmp sge i32 [[TMP29]], 0
; DATA-NEXT:    [[TMP31:%.*]] = select i1 [[TMP30]], float [[CSA_EXTRACT]], float 1.000000e+00
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_BODY]] ], [ [[TMP31]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_BODY]] ], [ [[TMP23]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    [[TMP32:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[ADD:%.*]] = phi float [ [[TMP32]], [[FOR_COND_CLEANUP_LOOPEXIT]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret float [[ADD]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[S_021:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[S_1]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_020:%.*]] = phi float [ 1.000000e+00, [[SCALAR_PH]] ], [ [[T_1]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA0]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP33:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP33]], 0.000000e+00
; DATA-NEXT:    [[T_1]] = select i1 [[CMP1]], float [[TMP33]], float [[T_020]]
; DATA-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds float, ptr [[DATA1]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP34:%.*]] = load float, ptr [[ARRAYIDX5]], align 4
; DATA-NEXT:    [[CMP6:%.*]] = fcmp ogt float [[TMP34]], 0.000000e+00
; DATA-NEXT:    [[S_1]] = select i1 [[CMP6]], float [[TMP34]], float [[S_021]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP13:![0-9]+]]
;
entry:
  %cmp19 = icmp sgt i32 %N, 0
  br i1 %cmp19, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %0 = fadd float %t.1, %s.1
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %add = phi float [ %0, %for.cond.cleanup.loopexit ], [ 2.000000e+00, %entry ]
  ret float %add

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %s.021 = phi float [ 1.000000e+00, %for.body.preheader ], [ %s.1, %for.body ]
  %t.020 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.1, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %data0, i64 %indvars.iv
  %1 = load float, ptr %arrayidx, align 4
  %cmp1 = fcmp ogt float %1, 0.000000e+00
  %t.1 = select i1 %cmp1, float %1, float %t.020
  %arrayidx5 = getelementptr inbounds float, ptr %data1, i64 %indvars.iv
  %2 = load float, ptr %arrayidx5, align 4
  %cmp6 = fcmp ogt float %2, 0.000000e+00
  %s.1 = select i1 %cmp6, float %2, float %s.021
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; int csa_in_series_int(int N, bool *cond0, bool *cond1, int *data0, int *data1) {
;   int t = -1;
;   int s = -1;
;   for (int i = 0; i < N; i++) {
;     if (cond0[i])
;       t = data0[i];
;     if (cond1[i])
;       s = data1[i];
;   }
;   return t | s; // use t and s
; }
define i32 @csa_in_series_int(i32 %N, ptr %cond0, ptr %cond1, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_in_series_int(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret i32 [[OR]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[S_017:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[IF_END]]
; EVL:       if.end:
; EVL-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; EVL:       if.then6:
; EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP4:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[S_1]] = phi i32 [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_END]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_in_series_int(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[OR]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[S_017:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[IF_END]]
; NO-EVL:       if.end:
; NO-EVL-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; NO-EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; NO-EVL:       if.then6:
; NO-EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[S_1]] = phi i32 [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_END]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_in_series_int(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret i32 [[OR]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[S_017:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[IF_END]]
; DATA:       if.end:
; DATA-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; DATA-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; DATA-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; DATA:       if.then6:
; DATA-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP4:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[S_1]] = phi i32 [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_END]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.inc
  %0 = or i32 %s.1, %t.1
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %or = phi i32 [ %0, %for.cond.cleanup.loopexit ], [ -1, %entry ]
  ret i32 %or

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %s.017 = phi i32 [ -1, %for.body.preheader ], [ %s.1, %for.inc ]
  %t.016 = phi i32 [ -1, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond0, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds i32, ptr %data0, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx2, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %t.1 = phi i32 [ %2, %if.then ], [ %t.016, %for.body ]
  %arrayidx4 = getelementptr inbounds i8, ptr %cond1, i64 %indvars.iv
  %3 = load i8, ptr %arrayidx4, align 1
  %tobool5.not = icmp eq i8 %3, 0
  br i1 %tobool5.not, label %for.inc, label %if.then6

if.then6:                                         ; preds = %if.end
  %arrayidx8 = getelementptr inbounds i32, ptr %data1, i64 %indvars.iv
  %4 = load i32, ptr %arrayidx8, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then6
  %s.1 = phi i32 [ %4, %if.then6 ], [ %s.017, %if.end ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; float csa_in_series_float(int N, bool *cond0, bool *cond1, float *data0,
;                           float *data1) {
;   float t = 1.0f;
;   float s = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (cond0[i])
;       t = data0[i];
;     if (cond1[i])
;       s = data1[i];
;   }
;   return t + s; // use t and s
; }
define float @csa_in_series_float(i32 %N, ptr %cond0, ptr %cond1, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_in_series_float(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret float [[ADD]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[S_017:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[IF_END]]
; EVL:       if.end:
; EVL-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; EVL:       if.then6:
; EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP4:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[S_1]] = phi float [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_END]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_in_series_float(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret float [[ADD]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[S_017:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[IF_END]]
; NO-EVL:       if.end:
; NO-EVL-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; NO-EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; NO-EVL:       if.then6:
; NO-EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[S_1]] = phi float [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_END]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_in_series_float(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret float [[ADD]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[S_017:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[IF_END]]
; DATA:       if.end:
; DATA-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; DATA-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; DATA-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; DATA:       if.then6:
; DATA-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP4:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[S_1]] = phi float [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_END]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.inc
  %0 = fadd float %t.1, %s.1
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %add = phi float [ %0, %for.cond.cleanup.loopexit ], [ 2.000000e+00, %entry ]
  ret float %add

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %s.017 = phi float [ 1.000000e+00, %for.body.preheader ], [ %s.1, %for.inc ]
  %t.016 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond0, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds float, ptr %data0, i64 %indvars.iv
  %2 = load float, ptr %arrayidx2, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %t.1 = phi float [ %2, %if.then ], [ %t.016, %for.body ]
  %arrayidx4 = getelementptr inbounds i8, ptr %cond1, i64 %indvars.iv
  %3 = load i8, ptr %arrayidx4, align 1
  %tobool5.not = icmp eq i8 %3, 0
  br i1 %tobool5.not, label %for.inc, label %if.then6

if.then6:                                         ; preds = %if.end
  %arrayidx8 = getelementptr inbounds float, ptr %data1, i64 %indvars.iv
  %4 = load float, ptr %arrayidx8, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then6
  %s.1 = phi float [ %4, %if.then6 ], [ %s.017, %if.end ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; int csa_in_series_same_scalar_int_select(int N, int *data0,
;                                   int *data1) {
;   int t = -1;
;   for (int i = 0; i < N; i++) {
;     if (i < data0[i])
;       t = data0[i];
;     if (i < data1[i])
;       t = data1[i];
;   }
;   return t; // use t
; }
define i32 @csa_in_series_same_scalar_int_select(i32 %N, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_in_series_same_scalar_int_select(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_2_LCSSA:%.*]] = phi i32 [ [[T_2:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP1]]
; EVL-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[CMP1]], i32 [[TMP0]], i32 [[T_022]]
; EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; EVL-NEXT:    [[TMP3:%.*]] = sext i32 [[TMP2]] to i64
; EVL-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP3]]
; EVL-NEXT:    [[T_2]] = select i1 [[CMP6]], i32 [[TMP2]], i32 [[SPEC_SELECT]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_in_series_same_scalar_int_select(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_2_LCSSA:%.*]] = phi i32 [ [[T_2:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; NO-EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP1]]
; NO-EVL-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[CMP1]], i32 [[TMP0]], i32 [[T_022]]
; NO-EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; NO-EVL-NEXT:    [[TMP3:%.*]] = sext i32 [[TMP2]] to i64
; NO-EVL-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP3]]
; NO-EVL-NEXT:    [[T_2]] = select i1 [[CMP6]], i32 [[TMP2]], i32 [[SPEC_SELECT]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_in_series_same_scalar_int_select(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP21:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP21]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_2_LCSSA:%.*]] = phi i32 [ [[T_2:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; DATA-NEXT:    ret i32 [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_022:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; DATA-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP1]]
; DATA-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[CMP1]], i32 [[TMP0]], i32 [[T_022]]
; DATA-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX5]], align 4
; DATA-NEXT:    [[TMP3:%.*]] = sext i32 [[TMP2]] to i64
; DATA-NEXT:    [[CMP6:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP3]]
; DATA-NEXT:    [[T_2]] = select i1 [[CMP6]], i32 [[TMP2]], i32 [[SPEC_SELECT]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp21 = icmp sgt i32 %N, 0
  br i1 %cmp21, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %t.0.lcssa = phi i32 [ -1, %entry ], [ %t.2, %for.body ]
  ret i32 %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %t.022 = phi i32 [ -1, %for.body.preheader ], [ %t.2, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %data0, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %1 = sext i32 %0 to i64
  %cmp1 = icmp slt i64 %indvars.iv, %1
  %spec.select = select i1 %cmp1, i32 %0, i32 %t.022
  %arrayidx5 = getelementptr inbounds i32, ptr %data1, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx5, align 4
  %3 = sext i32 %2 to i64
  %cmp6 = icmp slt i64 %indvars.iv, %3
  %t.2 = select i1 %cmp6, i32 %2, i32 %spec.select
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; float csa_in_series_same_scalar_float_select(int N,
;                                       float *data0, float *data1) {
;   float t = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (0.0f < data0[i])
;       t = data0[i];
;     if (0.0f < data1[i])
;       t = data1[i];
;   }
;   return t; // use t
; }
define float @csa_in_series_same_scalar_float_select(i32 %N, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_in_series_same_scalar_float_select(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP19:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP19]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_2_LCSSA:%.*]] = phi float [ [[T_2:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; EVL-NEXT:    ret float [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_020:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP0:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP0]], 0.000000e+00
; EVL-NEXT:    [[T_1:%.*]] = select i1 [[CMP1]], float [[TMP0]], float [[T_020]]
; EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX5]], align 4
; EVL-NEXT:    [[CMP6:%.*]] = fcmp ogt float [[TMP1]], 0.000000e+00
; EVL-NEXT:    [[T_2]] = select i1 [[CMP6]], float [[TMP1]], float [[T_1]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_in_series_same_scalar_float_select(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP19:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP19]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_2_LCSSA:%.*]] = phi float [ [[T_2:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; NO-EVL-NEXT:    ret float [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_020:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP0:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP0]], 0.000000e+00
; NO-EVL-NEXT:    [[T_1:%.*]] = select i1 [[CMP1]], float [[TMP0]], float [[T_020]]
; NO-EVL-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX5]], align 4
; NO-EVL-NEXT:    [[CMP6:%.*]] = fcmp ogt float [[TMP1]], 0.000000e+00
; NO-EVL-NEXT:    [[T_2]] = select i1 [[CMP6]], float [[TMP1]], float [[T_1]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_in_series_same_scalar_float_select(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP19:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP19]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_2_LCSSA:%.*]] = phi float [ [[T_2:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; DATA-NEXT:    ret float [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_020:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP0:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[CMP1:%.*]] = fcmp ogt float [[TMP0]], 0.000000e+00
; DATA-NEXT:    [[T_1:%.*]] = select i1 [[CMP1]], float [[TMP0]], float [[T_020]]
; DATA-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX5]], align 4
; DATA-NEXT:    [[CMP6:%.*]] = fcmp ogt float [[TMP1]], 0.000000e+00
; DATA-NEXT:    [[T_2]] = select i1 [[CMP6]], float [[TMP1]], float [[T_1]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp19 = icmp sgt i32 %N, 0
  br i1 %cmp19, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %t.0.lcssa = phi float [ 1.000000e+00, %entry ], [ %t.2, %for.body ]
  ret float %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %t.020 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.2, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %data0, i64 %indvars.iv
  %0 = load float, ptr %arrayidx, align 4
  %cmp1 = fcmp ogt float %0, 0.000000e+00
  %t.1 = select i1 %cmp1, float %0, float %t.020
  %arrayidx5 = getelementptr inbounds float, ptr %data1, i64 %indvars.iv
  %1 = load float, ptr %arrayidx5, align 4
  %cmp6 = fcmp ogt float %1, 0.000000e+00
  %t.2 = select i1 %cmp6, float %1, float %t.1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; int csa_in_series_same_scalar_int(int N, bool *cond0, bool *cond1, int *data0,
;                                   int *data1) {
;   int t = -1;
;   for (int i = 0; i < N; i++) {
;     if (cond0[i])
;       t = data0[i];
;     if (cond1[i])
;       t = data1[i];
;   }
;   return t; // use t
; }
define i32 @csa_in_series_same_scalar_int(i32 %N, ptr %cond0, ptr %cond1, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_in_series_same_scalar_int(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_2_LCSSA:%.*]] = phi i32 [ [[T_2:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[IF_END]]
; EVL:       if.end:
; EVL-NEXT:    [[T_1:%.*]] = phi i32 [ [[TMP1]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP2]], 0
; EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; EVL:       if.then6:
; EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP3:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_2]] = phi i32 [ [[TMP3]], [[IF_THEN6]] ], [ [[T_1]], [[IF_END]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_in_series_same_scalar_int(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_2_LCSSA:%.*]] = phi i32 [ [[T_2:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[IF_END]]
; NO-EVL:       if.end:
; NO-EVL-NEXT:    [[T_1:%.*]] = phi i32 [ [[TMP1]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; NO-EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP2]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; NO-EVL:       if.then6:
; NO-EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP3:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_2]] = phi i32 [ [[TMP3]], [[IF_THEN6]] ], [ [[T_1]], [[IF_END]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_in_series_same_scalar_int(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_2_LCSSA:%.*]] = phi i32 [ [[T_2:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; DATA-NEXT:    ret i32 [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[IF_END]]
; DATA:       if.end:
; DATA-NEXT:    [[T_1:%.*]] = phi i32 [ [[TMP1]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; DATA-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP2]], 0
; DATA-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; DATA:       if.then6:
; DATA-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP3:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_2]] = phi i32 [ [[TMP3]], [[IF_THEN6]] ], [ [[T_1]], [[IF_END]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %entry
  %t.0.lcssa = phi i32 [ -1, %entry ], [ %t.2, %for.inc ]
  ret i32 %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %t.016 = phi i32 [ -1, %for.body.preheader ], [ %t.2, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond0, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds i32, ptr %data0, i64 %indvars.iv
  %1 = load i32, ptr %arrayidx2, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %t.1 = phi i32 [ %1, %if.then ], [ %t.016, %for.body ]
  %arrayidx4 = getelementptr inbounds i8, ptr %cond1, i64 %indvars.iv
  %2 = load i8, ptr %arrayidx4, align 1
  %tobool5.not = icmp eq i8 %2, 0
  br i1 %tobool5.not, label %for.inc, label %if.then6

if.then6:                                         ; preds = %if.end
  %arrayidx8 = getelementptr inbounds i32, ptr %data1, i64 %indvars.iv
  %3 = load i32, ptr %arrayidx8, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then6
  %t.2 = phi i32 [ %3, %if.then6 ], [ %t.1, %if.end ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; float csa_in_series_same_scalar_float(int N, bool *cond0, bool *cond1,
;                                       float *data0, float *data1) {
;   float t = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (cond0[i])
;       t = data0[i];
;     if (cond1[i])
;       t = data1[i];
;   }
;   return t; // use t
; }
define float @csa_in_series_same_scalar_float(i32 %N, ptr %cond0, ptr %cond1, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_in_series_same_scalar_float(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_2_LCSSA:%.*]] = phi float [ [[T_2:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; EVL-NEXT:    ret float [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[IF_END]]
; EVL:       if.end:
; EVL-NEXT:    [[T_1:%.*]] = phi float [ [[TMP1]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP2]], 0
; EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; EVL:       if.then6:
; EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP3:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_2]] = phi float [ [[TMP3]], [[IF_THEN6]] ], [ [[T_1]], [[IF_END]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_in_series_same_scalar_float(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_2_LCSSA:%.*]] = phi float [ [[T_2:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; NO-EVL-NEXT:    ret float [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[IF_END]]
; NO-EVL:       if.end:
; NO-EVL-NEXT:    [[T_1:%.*]] = phi float [ [[TMP1]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; NO-EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP2]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; NO-EVL:       if.then6:
; NO-EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP3:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_2]] = phi float [ [[TMP3]], [[IF_THEN6]] ], [ [[T_1]], [[IF_END]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_in_series_same_scalar_float(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_2_LCSSA:%.*]] = phi float [ [[T_2:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_2_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; DATA-NEXT:    ret float [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_2]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[IF_END]]
; DATA:       if.end:
; DATA-NEXT:    [[T_1:%.*]] = phi float [ [[TMP1]], [[IF_THEN]] ], [ [[T_016]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; DATA-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP2]], 0
; DATA-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; DATA:       if.then6:
; DATA-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP3:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_2]] = phi float [ [[TMP3]], [[IF_THEN6]] ], [ [[T_1]], [[IF_END]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %entry
  %t.0.lcssa = phi float [ 1.000000e+00, %entry ], [ %t.2, %for.inc ]
  ret float %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %t.016 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.2, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond0, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds float, ptr %data0, i64 %indvars.iv
  %1 = load float, ptr %arrayidx2, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %t.1 = phi float [ %1, %if.then ], [ %t.016, %for.body ]
  %arrayidx4 = getelementptr inbounds i8, ptr %cond1, i64 %indvars.iv
  %2 = load i8, ptr %arrayidx4, align 1
  %tobool5.not = icmp eq i8 %2, 0
  br i1 %tobool5.not, label %for.inc, label %if.then6

if.then6:                                         ; preds = %if.end
  %arrayidx8 = getelementptr inbounds float, ptr %data1, i64 %indvars.iv
  %3 = load float, ptr %arrayidx8, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then6
  %t.2 = phi float [ %3, %if.then6 ], [ %t.1, %if.end ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; int csa_same_cond_int(int N, bool *cond, int *data0, int *data1) {
;   int t = -1;
;   int s = -1;
;   for (int i = 0; i < N; i++) {
;     if (cond[i]) {
;       t = data0[i];
;       s = data1[i];
;     }
;   }
;   return t | s; // use t and s
; }
define i32 @csa_same_cond_int(i32 %N, ptr %cond, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_same_cond_int(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret i32 [[OR]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[S_011:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP3:%.*]] = load i32, ptr [[ARRAYIDX4]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_010]], [[FOR_BODY]] ]
; EVL-NEXT:    [[S_1]] = phi i32 [ [[TMP3]], [[IF_THEN]] ], [ [[S_011]], [[FOR_BODY]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_same_cond_int(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[OR]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[S_011:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP3:%.*]] = load i32, ptr [[ARRAYIDX4]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_010]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[S_1]] = phi i32 [ [[TMP3]], [[IF_THEN]] ], [ [[S_011]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_same_cond_int(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret i32 [[OR]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[S_011:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_010:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP3:%.*]] = load i32, ptr [[ARRAYIDX4]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_010]], [[FOR_BODY]] ]
; DATA-NEXT:    [[S_1]] = phi i32 [ [[TMP3]], [[IF_THEN]] ], [ [[S_011]], [[FOR_BODY]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp9 = icmp sgt i32 %N, 0
  br i1 %cmp9, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.inc
  %0 = or i32 %s.1, %t.1
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %or = phi i32 [ %0, %for.cond.cleanup.loopexit ], [ -1, %entry ]
  ret i32 %or

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %s.011 = phi i32 [ -1, %for.body.preheader ], [ %s.1, %for.inc ]
  %t.010 = phi i32 [ -1, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds i32, ptr %data0, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds i32, ptr %data1, i64 %indvars.iv
  %3 = load i32, ptr %arrayidx4, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %t.1 = phi i32 [ %2, %if.then ], [ %t.010, %for.body ]
  %s.1 = phi i32 [ %3, %if.then ], [ %s.011, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; float csa_same_cond_float(int N, bool *cond, float *data0, float *data1) {
;   float t = 1.0f;
;   float s = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (cond[i]) {
;       t = data0[i];
;       s = data1[i];
;     }
;   }
;   return t + s; // use t and s
; }
define float @csa_same_cond_float(i32 %N, ptr %cond, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_same_cond_float(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret float [[ADD]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[S_011:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_010:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP3:%.*]] = load float, ptr [[ARRAYIDX4]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_010]], [[FOR_BODY]] ]
; EVL-NEXT:    [[S_1]] = phi float [ [[TMP3]], [[IF_THEN]] ], [ [[S_011]], [[FOR_BODY]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_same_cond_float(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret float [[ADD]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[S_011:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_010:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP3:%.*]] = load float, ptr [[ARRAYIDX4]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_010]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[S_1]] = phi float [ [[TMP3]], [[IF_THEN]] ], [ [[S_011]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_same_cond_float(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret float [[ADD]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[S_011:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_010:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP3:%.*]] = load float, ptr [[ARRAYIDX4]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_010]], [[FOR_BODY]] ]
; DATA-NEXT:    [[S_1]] = phi float [ [[TMP3]], [[IF_THEN]] ], [ [[S_011]], [[FOR_BODY]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp9 = icmp sgt i32 %N, 0
  br i1 %cmp9, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.inc
  %0 = fadd float %t.1, %s.1
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %add = phi float [ %0, %for.cond.cleanup.loopexit ], [ 2.000000e+00, %entry ]
  ret float %add

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %s.011 = phi float [ 1.000000e+00, %for.body.preheader ], [ %s.1, %for.inc ]
  %t.010 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds float, ptr %data0, i64 %indvars.iv
  %2 = load float, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds float, ptr %data1, i64 %indvars.iv
  %3 = load float, ptr %arrayidx4, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %t.1 = phi float [ %2, %if.then ], [ %t.010, %for.body ]
  %s.1 = phi float [ %3, %if.then ], [ %s.011, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; int csa_else_if_same_scalar_int(int N, bool *cond0, bool *cond1, int *data0,
;                                 int *data1) {
;   int t = -1;
;   for (int i = 0; i < N; i++) {
;     if (cond0[i])
;       t = data0[i];
;     else if (cond1[i])
;       t = data1[i];
;   }
;   return t; // use t
; }
define i32 @csa_else_if_same_scalar_int(i32 %N, ptr %cond0, ptr %cond1, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_else_if_same_scalar_int(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[FOR_INC_SINK_SPLIT:%.*]]
; EVL:       if.else:
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[FOR_INC_SINK_SPLIT]]
; EVL:       for.inc.sink.split:
; EVL-NEXT:    [[DATA0_SINK:%.*]] = phi ptr [ [[DATA0:%.*]], [[FOR_BODY]] ], [ [[DATA1:%.*]], [[IF_ELSE]] ]
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0_SINK]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_1]] = phi i32 [ [[T_016]], [[IF_ELSE]] ], [ [[TMP2]], [[FOR_INC_SINK_SPLIT]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_else_if_same_scalar_int(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[FOR_INC_SINK_SPLIT:%.*]]
; NO-EVL:       if.else:
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; NO-EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[FOR_INC_SINK_SPLIT]]
; NO-EVL:       for.inc.sink.split:
; NO-EVL-NEXT:    [[DATA0_SINK:%.*]] = phi ptr [ [[DATA0:%.*]], [[FOR_BODY]] ], [ [[DATA1:%.*]], [[IF_ELSE]] ]
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0_SINK]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_1]] = phi i32 [ [[T_016]], [[IF_ELSE]] ], [ [[TMP2]], [[FOR_INC_SINK_SPLIT]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_else_if_same_scalar_int(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ -1, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; DATA-NEXT:    ret i32 [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[FOR_INC_SINK_SPLIT:%.*]]
; DATA:       if.else:
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; DATA-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; DATA-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[FOR_INC_SINK_SPLIT]]
; DATA:       for.inc.sink.split:
; DATA-NEXT:    [[DATA0_SINK:%.*]] = phi ptr [ [[DATA0:%.*]], [[FOR_BODY]] ], [ [[DATA1:%.*]], [[IF_ELSE]] ]
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0_SINK]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_1]] = phi i32 [ [[T_016]], [[IF_ELSE]] ], [ [[TMP2]], [[FOR_INC_SINK_SPLIT]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %entry
  %t.0.lcssa = phi i32 [ -1, %entry ], [ %t.1, %for.inc ]
  ret i32 %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %t.016 = phi i32 [ -1, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond0, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.else, label %for.inc.sink.split

if.else:                                          ; preds = %for.body
  %arrayidx4 = getelementptr inbounds i8, ptr %cond1, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx4, align 1
  %tobool5.not = icmp eq i8 %1, 0
  br i1 %tobool5.not, label %for.inc, label %for.inc.sink.split

for.inc.sink.split:                               ; preds = %if.else, %for.body
  %data0.sink = phi ptr [ %data0, %for.body ], [ %data1, %if.else ]
  %arrayidx2 = getelementptr inbounds i32, ptr %data0.sink, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.inc.sink.split, %if.else
  %t.1 = phi i32 [ %t.016, %if.else ], [ %2, %for.inc.sink.split ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; float csa_else_if_same_scalar_float(int N, bool *cond0, bool *cond1,
;                                     float *data0, float *data1) {
;   float t = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (cond0[i])
;       t = data0[i];
;     else if (cond1[i])
;       t = data1[i];
;   }
;   return t; // use t
; }
define float @csa_else_if_same_scalar_float(i32 %N, ptr %cond0, ptr %cond1, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_else_if_same_scalar_float(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; EVL-NEXT:    ret float [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[FOR_INC_SINK_SPLIT:%.*]]
; EVL:       if.else:
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[FOR_INC_SINK_SPLIT]]
; EVL:       for.inc.sink.split:
; EVL-NEXT:    [[DATA0_SINK:%.*]] = phi ptr [ [[DATA0:%.*]], [[FOR_BODY]] ], [ [[DATA1:%.*]], [[IF_ELSE]] ]
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0_SINK]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_1]] = phi float [ [[T_016]], [[IF_ELSE]] ], [ [[TMP2]], [[FOR_INC_SINK_SPLIT]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_else_if_same_scalar_float(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; NO-EVL-NEXT:    ret float [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[FOR_INC_SINK_SPLIT:%.*]]
; NO-EVL:       if.else:
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; NO-EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[FOR_INC_SINK_SPLIT]]
; NO-EVL:       for.inc.sink.split:
; NO-EVL-NEXT:    [[DATA0_SINK:%.*]] = phi ptr [ [[DATA0:%.*]], [[FOR_BODY]] ], [ [[DATA1:%.*]], [[IF_ELSE]] ]
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0_SINK]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_1]] = phi float [ [[T_016]], [[IF_ELSE]] ], [ [[TMP2]], [[FOR_INC_SINK_SPLIT]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_else_if_same_scalar_float(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi float [ 1.000000e+00, [[ENTRY:%.*]] ], [ [[T_1_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ]
; DATA-NEXT:    ret float [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP0]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[FOR_INC_SINK_SPLIT:%.*]]
; DATA:       if.else:
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; DATA-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; DATA-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[FOR_INC_SINK_SPLIT]]
; DATA:       for.inc.sink.split:
; DATA-NEXT:    [[DATA0_SINK:%.*]] = phi ptr [ [[DATA0:%.*]], [[FOR_BODY]] ], [ [[DATA1:%.*]], [[IF_ELSE]] ]
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0_SINK]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_1]] = phi float [ [[T_016]], [[IF_ELSE]] ], [ [[TMP2]], [[FOR_INC_SINK_SPLIT]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %entry
  %t.0.lcssa = phi float [ 1.000000e+00, %entry ], [ %t.1, %for.inc ]
  ret float %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %t.016 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond0, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %0, 0
  br i1 %tobool.not, label %if.else, label %for.inc.sink.split

if.else:                                          ; preds = %for.body
  %arrayidx4 = getelementptr inbounds i8, ptr %cond1, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx4, align 1
  %tobool5.not = icmp eq i8 %1, 0
  br i1 %tobool5.not, label %for.inc, label %for.inc.sink.split

for.inc.sink.split:                               ; preds = %if.else, %for.body
  %data0.sink = phi ptr [ %data0, %for.body ], [ %data1, %if.else ]
  %arrayidx2 = getelementptr inbounds float, ptr %data0.sink, i64 %indvars.iv
  %2 = load float, ptr %arrayidx2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.inc.sink.split, %if.else
  %t.1 = phi float [ %t.016, %if.else ], [ %2, %for.inc.sink.split ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; This function is generated from the following C/C++ program:
; int csa_else_if_int(int N, bool *cond0, bool *cond1, int *data0, int *data1) {
;   int t = -1;
;   int s = -1;
;   for (int i = 0; i < N; i++) {
;     if (cond0[i])
;       t = data0[i];
;     else if (cond1[i])
;       s = data1[i];
;   }
;   return t | s; // use t and s
; }
define i32 @csa_else_if_int(i32 %N, ptr %cond0, ptr %cond1, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_else_if_int(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret i32 [[OR]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[S_017:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       if.else:
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; EVL:       if.then6:
; EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP4:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[IF_THEN6]] ], [ [[T_016]], [[IF_ELSE]] ]
; EVL-NEXT:    [[S_1]] = phi i32 [ [[S_017]], [[IF_THEN]] ], [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_ELSE]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_else_if_int(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret i32 [[OR]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[S_017:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       if.else:
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; NO-EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; NO-EVL:       if.then6:
; NO-EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[IF_THEN6]] ], [ [[T_016]], [[IF_ELSE]] ]
; NO-EVL-NEXT:    [[S_1]] = phi i32 [ [[S_017]], [[IF_THEN]] ], [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_ELSE]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_else_if_int(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi i32 [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi i32 [ [[S_1:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[TMP0:%.*]] = or i32 [[S_1_LCSSA]], [[T_1_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[OR:%.*]] = phi i32 [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ -1, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret i32 [[OR]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[S_017:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_016:%.*]] = phi i32 [ -1, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       if.else:
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; DATA-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; DATA-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; DATA:       if.then6:
; DATA-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP4:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_1]] = phi i32 [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[IF_THEN6]] ], [ [[T_016]], [[IF_ELSE]] ]
; DATA-NEXT:    [[S_1]] = phi i32 [ [[S_017]], [[IF_THEN]] ], [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_ELSE]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.inc
  %0 = or i32 %s.1, %t.1
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %or = phi i32 [ %0, %for.cond.cleanup.loopexit ], [ -1, %entry ]
  ret i32 %or

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %s.017 = phi i32 [ -1, %for.body.preheader ], [ %s.1, %for.inc ]
  %t.016 = phi i32 [ -1, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond0, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds i32, ptr %data0, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx2, align 4
  br label %for.inc

if.else:                                          ; preds = %for.body
  %arrayidx4 = getelementptr inbounds i8, ptr %cond1, i64 %indvars.iv
  %3 = load i8, ptr %arrayidx4, align 1
  %tobool5.not = icmp eq i8 %3, 0
  br i1 %tobool5.not, label %for.inc, label %if.then6

if.then6:                                         ; preds = %if.else
  %arrayidx8 = getelementptr inbounds i32, ptr %data1, i64 %indvars.iv
  %4 = load i32, ptr %arrayidx8, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.then, %if.then6, %if.else
  %t.1 = phi i32 [ %2, %if.then ], [ %t.016, %if.then6 ], [ %t.016, %if.else ]
  %s.1 = phi i32 [ %s.017, %if.then ], [ %4, %if.then6 ], [ %s.017, %if.else ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; float csa_else_if_float(int N, bool *cond0, bool *cond1, float *data0,
;                         float *data1) {
;   float t = 1.0f;
;   float s = 1.0f;
;   for (int i = 0; i < N; i++) {
;     if (cond0[i])
;       t = data0[i];
;     else if (cond1[i])
;       s = data1[i];
;   }
;   return t + s; // use t and s
; }
define float @csa_else_if_float(i32 %N, ptr %cond0, ptr %cond1, ptr %data0, ptr %data1) {
; EVL-LABEL: @csa_else_if_float(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; EVL-NEXT:    ret float [[ADD]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; EVL-NEXT:    [[S_017:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]]
; EVL:       if.then:
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       if.else:
; EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; EVL:       if.then6:
; EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP4:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; EVL-NEXT:    br label [[FOR_INC]]
; EVL:       for.inc:
; EVL-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[IF_THEN6]] ], [ [[T_016]], [[IF_ELSE]] ]
; EVL-NEXT:    [[S_1]] = phi float [ [[S_017]], [[IF_THEN]] ], [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_ELSE]] ]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; NO-EVL-LABEL: @csa_else_if_float(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; NO-EVL-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; NO-EVL-NEXT:    ret float [[ADD]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[S_017:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; NO-EVL-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]]
; NO-EVL:       if.then:
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       if.else:
; NO-EVL-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; NO-EVL-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; NO-EVL-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; NO-EVL:       if.then6:
; NO-EVL-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; NO-EVL-NEXT:    br label [[FOR_INC]]
; NO-EVL:       for.inc:
; NO-EVL-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[IF_THEN6]] ], [ [[T_016]], [[IF_ELSE]] ]
; NO-EVL-NEXT:    [[S_1]] = phi float [ [[S_017]], [[IF_THEN]] ], [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_ELSE]] ]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
; DATA-LABEL: @csa_else_if_float(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP15:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP15]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[T_1_LCSSA:%.*]] = phi float [ [[T_1:%.*]], [[FOR_INC:%.*]] ]
; DATA-NEXT:    [[S_1_LCSSA:%.*]] = phi float [ [[S_1:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[TMP0:%.*]] = fadd float [[T_1_LCSSA]], [[S_1_LCSSA]]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[ADD:%.*]] = phi float [ [[TMP0]], [[FOR_COND_CLEANUP_LOOPEXIT:%.*]] ], [ 2.000000e+00, [[ENTRY:%.*]] ]
; DATA-NEXT:    ret float [[ADD]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC]] ]
; DATA-NEXT:    [[S_017:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[S_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[T_016:%.*]] = phi float [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[T_1]], [[FOR_INC]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[COND0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; DATA-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i8 [[TMP1]], 0
; DATA-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]]
; DATA:       if.then:
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[DATA0:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX2]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       if.else:
; DATA-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[COND1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP3:%.*]] = load i8, ptr [[ARRAYIDX4]], align 1
; DATA-NEXT:    [[TOBOOL5_NOT:%.*]] = icmp eq i8 [[TMP3]], 0
; DATA-NEXT:    br i1 [[TOBOOL5_NOT]], label [[FOR_INC]], label [[IF_THEN6:%.*]]
; DATA:       if.then6:
; DATA-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[DATA1:%.*]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP4:%.*]] = load float, ptr [[ARRAYIDX8]], align 4
; DATA-NEXT:    br label [[FOR_INC]]
; DATA:       for.inc:
; DATA-NEXT:    [[T_1]] = phi float [ [[TMP2]], [[IF_THEN]] ], [ [[T_016]], [[IF_THEN6]] ], [ [[T_016]], [[IF_ELSE]] ]
; DATA-NEXT:    [[S_1]] = phi float [ [[S_017]], [[IF_THEN]] ], [ [[TMP4]], [[IF_THEN6]] ], [ [[S_017]], [[IF_ELSE]] ]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.inc
  %0 = fadd float %t.1, %s.1
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %add = phi float [ %0, %for.cond.cleanup.loopexit ], [ 2.000000e+00, %entry ]
  ret float %add

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %s.017 = phi float [ 1.000000e+00, %for.body.preheader ], [ %s.1, %for.inc ]
  %t.016 = phi float [ 1.000000e+00, %for.body.preheader ], [ %t.1, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %cond0, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %1, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds float, ptr %data0, i64 %indvars.iv
  %2 = load float, ptr %arrayidx2, align 4
  br label %for.inc

if.else:                                          ; preds = %for.body
  %arrayidx4 = getelementptr inbounds i8, ptr %cond1, i64 %indvars.iv
  %3 = load i8, ptr %arrayidx4, align 1
  %tobool5.not = icmp eq i8 %3, 0
  br i1 %tobool5.not, label %for.inc, label %if.then6

if.then6:                                         ; preds = %if.else
  %arrayidx8 = getelementptr inbounds float, ptr %data1, i64 %indvars.iv
  %4 = load float, ptr %arrayidx8, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.then, %if.then6, %if.else
  %t.1 = phi float [ %2, %if.then ], [ %t.016, %if.then6 ], [ %t.016, %if.else ]
  %s.1 = phi float [ %s.017, %if.then ], [ %4, %if.then6 ], [ %s.017, %if.else ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; uint64_t idx_scalar(int64_t *a, int64_t *b, uint64_t ii, uint64_t n) {
;   uint64_t idx = ii;
;   for (uint64_t i = 0; i < n; ++i)
;     idx = (a[i] > b[i]) ? i : idx;
;   return idx;
; }
define i64 @idx_scalar(ptr %a, ptr %b, i64 %ii, i64 %n) {
; EVL-LABEL: @idx_scalar(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP8_NOT:%.*]] = icmp eq i64 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP8_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 2
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 2
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[N]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[N]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 2
; EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 2 x i64> @llvm.stepvector.nxv2i64()
; EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 2 x i64> [[TMP6]], zeroinitializer
; EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 2 x i64> [[TMP7]], shufflevector (<vscale x 2 x i64> insertelement (<vscale x 2 x i64> poison, i64 1, i64 0), <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer)
; EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 2 x i64> zeroinitializer, [[TMP8]]
; EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 2
; EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 2 x i64> poison, i64 [[TMP11]], i64 0
; EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 2 x i64> [[DOTSPLATINSERT]], <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 2 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 2 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 2 x i64> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[TMP12]]
; EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i64, ptr [[TMP13]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 2 x i64>, ptr [[TMP14]], align 8
; EVL-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i64, ptr [[B:%.*]], i64 [[TMP12]]
; EVL-NEXT:    [[TMP16:%.*]] = getelementptr inbounds i64, ptr [[TMP15]], i32 0
; EVL-NEXT:    [[WIDE_LOAD1:%.*]] = load <vscale x 2 x i64>, ptr [[TMP16]], align 8
; EVL-NEXT:    [[TMP17:%.*]] = icmp sgt <vscale x 2 x i64> [[WIDE_LOAD]], [[WIDE_LOAD1]]
; EVL-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> [[TMP17]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP18]], <vscale x 2 x i1> [[TMP17]], <vscale x 2 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP18]], <vscale x 2 x i64> [[VEC_IND]], <vscale x 2 x i64> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 2 x i64> [[VEC_IND]], [[DOTSPLAT]]
; EVL-NEXT:    [[TMP19:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP14:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 2 x i32> @llvm.stepvector.nxv2i32()
; EVL-NEXT:    [[TMP20:%.*]] = select <vscale x 2 x i1> [[CSA_MASK_SEL]], <vscale x 2 x i32> [[CSA_STEP]], <vscale x 2 x i32> zeroinitializer
; EVL-NEXT:    [[TMP21:%.*]] = call i32 @llvm.vector.reduce.umax.nxv2i32(<vscale x 2 x i32> [[TMP20]])
; EVL-NEXT:    [[TMP22:%.*]] = extractelement <vscale x 2 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP23:%.*]] = icmp eq i32 [[TMP21]], 0
; EVL-NEXT:    [[TMP24:%.*]] = and i1 [[TMP22]], [[TMP23]]
; EVL-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 2 x i64> [[CSA_DATA_SEL]], i32 [[TMP25]]
; EVL-NEXT:    [[TMP26:%.*]] = icmp sge i32 [[TMP25]], 0
; EVL-NEXT:    [[TMP27:%.*]] = select i1 [[TMP26]], i64 [[CSA_EXTRACT]], i64 [[II:%.*]]
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[COND_LCSSA:%.*]] = phi i64 [ [[COND:%.*]], [[FOR_BODY]] ], [ [[TMP27]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[IDX_0_LCSSA:%.*]] = phi i64 [ [[II]], [[ENTRY:%.*]] ], [ [[COND_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; EVL-NEXT:    ret i64 [[IDX_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[I_010:%.*]] = phi i64 [ [[INC:%.*]], [[FOR_BODY]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ]
; EVL-NEXT:    [[IDX_09:%.*]] = phi i64 [ [[COND]], [[FOR_BODY]] ], [ [[II]], [[SCALAR_PH]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[I_010]]
; EVL-NEXT:    [[TMP28:%.*]] = load i64, ptr [[ARRAYIDX]], align 8
; EVL-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[I_010]]
; EVL-NEXT:    [[TMP29:%.*]] = load i64, ptr [[ARRAYIDX1]], align 8
; EVL-NEXT:    [[CMP2:%.*]] = icmp sgt i64 [[TMP28]], [[TMP29]]
; EVL-NEXT:    [[COND]] = select i1 [[CMP2]], i64 [[I_010]], i64 [[IDX_09]]
; EVL-NEXT:    [[INC]] = add nuw i64 [[I_010]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INC]], [[N]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP15:![0-9]+]]
;
; NO-EVL-LABEL: @idx_scalar(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP8_NOT:%.*]] = icmp eq i64 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP8_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 2
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 2
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[N]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[N]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 2
; NO-EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 2 x i64> @llvm.stepvector.nxv2i64()
; NO-EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 2 x i64> [[TMP6]], zeroinitializer
; NO-EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 2 x i64> [[TMP7]], shufflevector (<vscale x 2 x i64> insertelement (<vscale x 2 x i64> poison, i64 1, i64 0), <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer)
; NO-EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 2 x i64> zeroinitializer, [[TMP8]]
; NO-EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 2
; NO-EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; NO-EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 2 x i64> poison, i64 [[TMP11]], i64 0
; NO-EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 2 x i64> [[DOTSPLATINSERT]], <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 2 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 2 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 2 x i64> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[TMP12]]
; NO-EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i64, ptr [[TMP13]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 2 x i64>, ptr [[TMP14]], align 8
; NO-EVL-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i64, ptr [[B:%.*]], i64 [[TMP12]]
; NO-EVL-NEXT:    [[TMP16:%.*]] = getelementptr inbounds i64, ptr [[TMP15]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD1:%.*]] = load <vscale x 2 x i64>, ptr [[TMP16]], align 8
; NO-EVL-NEXT:    [[TMP17:%.*]] = icmp sgt <vscale x 2 x i64> [[WIDE_LOAD]], [[WIDE_LOAD1]]
; NO-EVL-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> [[TMP17]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP18]], <vscale x 2 x i1> [[TMP17]], <vscale x 2 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP18]], <vscale x 2 x i64> [[VEC_IND]], <vscale x 2 x i64> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 2 x i64> [[VEC_IND]], [[DOTSPLAT]]
; NO-EVL-NEXT:    [[TMP19:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP14:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 2 x i32> @llvm.stepvector.nxv2i32()
; NO-EVL-NEXT:    [[TMP20:%.*]] = select <vscale x 2 x i1> [[CSA_MASK_SEL]], <vscale x 2 x i32> [[CSA_STEP]], <vscale x 2 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP21:%.*]] = call i32 @llvm.vector.reduce.umax.nxv2i32(<vscale x 2 x i32> [[TMP20]])
; NO-EVL-NEXT:    [[TMP22:%.*]] = extractelement <vscale x 2 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP23:%.*]] = icmp eq i32 [[TMP21]], 0
; NO-EVL-NEXT:    [[TMP24:%.*]] = and i1 [[TMP22]], [[TMP23]]
; NO-EVL-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 2 x i64> [[CSA_DATA_SEL]], i32 [[TMP25]]
; NO-EVL-NEXT:    [[TMP26:%.*]] = icmp sge i32 [[TMP25]], 0
; NO-EVL-NEXT:    [[TMP27:%.*]] = select i1 [[TMP26]], i64 [[CSA_EXTRACT]], i64 [[II:%.*]]
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[COND_LCSSA:%.*]] = phi i64 [ [[COND:%.*]], [[FOR_BODY]] ], [ [[TMP27]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[IDX_0_LCSSA:%.*]] = phi i64 [ [[II]], [[ENTRY:%.*]] ], [ [[COND_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; NO-EVL-NEXT:    ret i64 [[IDX_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[I_010:%.*]] = phi i64 [ [[INC:%.*]], [[FOR_BODY]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ]
; NO-EVL-NEXT:    [[IDX_09:%.*]] = phi i64 [ [[COND]], [[FOR_BODY]] ], [ [[II]], [[SCALAR_PH]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[I_010]]
; NO-EVL-NEXT:    [[TMP28:%.*]] = load i64, ptr [[ARRAYIDX]], align 8
; NO-EVL-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[I_010]]
; NO-EVL-NEXT:    [[TMP29:%.*]] = load i64, ptr [[ARRAYIDX1]], align 8
; NO-EVL-NEXT:    [[CMP2:%.*]] = icmp sgt i64 [[TMP28]], [[TMP29]]
; NO-EVL-NEXT:    [[COND]] = select i1 [[CMP2]], i64 [[I_010]], i64 [[IDX_09]]
; NO-EVL-NEXT:    [[INC]] = add nuw i64 [[I_010]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INC]], [[N]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP15:![0-9]+]]
;
; DATA-LABEL: @idx_scalar(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP8_NOT:%.*]] = icmp eq i64 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP8_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 2
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 2
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[N]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[N]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 2
; DATA-NEXT:    [[TMP6:%.*]] = call <vscale x 2 x i64> @llvm.stepvector.nxv2i64()
; DATA-NEXT:    [[TMP7:%.*]] = add <vscale x 2 x i64> [[TMP6]], zeroinitializer
; DATA-NEXT:    [[TMP8:%.*]] = mul <vscale x 2 x i64> [[TMP7]], shufflevector (<vscale x 2 x i64> insertelement (<vscale x 2 x i64> poison, i64 1, i64 0), <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer)
; DATA-NEXT:    [[INDUCTION:%.*]] = add <vscale x 2 x i64> zeroinitializer, [[TMP8]]
; DATA-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 2
; DATA-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; DATA-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 2 x i64> poison, i64 [[TMP11]], i64 0
; DATA-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 2 x i64> [[DOTSPLATINSERT]], <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 2 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 2 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 2 x i64> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[TMP12]]
; DATA-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i64, ptr [[TMP13]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 2 x i64>, ptr [[TMP14]], align 8
; DATA-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i64, ptr [[B:%.*]], i64 [[TMP12]]
; DATA-NEXT:    [[TMP16:%.*]] = getelementptr inbounds i64, ptr [[TMP15]], i32 0
; DATA-NEXT:    [[WIDE_LOAD1:%.*]] = load <vscale x 2 x i64>, ptr [[TMP16]], align 8
; DATA-NEXT:    [[TMP17:%.*]] = icmp sgt <vscale x 2 x i64> [[WIDE_LOAD]], [[WIDE_LOAD1]]
; DATA-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> [[TMP17]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP18]], <vscale x 2 x i1> [[TMP17]], <vscale x 2 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP18]], <vscale x 2 x i64> [[VEC_IND]], <vscale x 2 x i64> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 2 x i64> [[VEC_IND]], [[DOTSPLAT]]
; DATA-NEXT:    [[TMP19:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP14:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 2 x i32> @llvm.stepvector.nxv2i32()
; DATA-NEXT:    [[TMP20:%.*]] = select <vscale x 2 x i1> [[CSA_MASK_SEL]], <vscale x 2 x i32> [[CSA_STEP]], <vscale x 2 x i32> zeroinitializer
; DATA-NEXT:    [[TMP21:%.*]] = call i32 @llvm.vector.reduce.umax.nxv2i32(<vscale x 2 x i32> [[TMP20]])
; DATA-NEXT:    [[TMP22:%.*]] = extractelement <vscale x 2 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP23:%.*]] = icmp eq i32 [[TMP21]], 0
; DATA-NEXT:    [[TMP24:%.*]] = and i1 [[TMP22]], [[TMP23]]
; DATA-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 2 x i64> [[CSA_DATA_SEL]], i32 [[TMP25]]
; DATA-NEXT:    [[TMP26:%.*]] = icmp sge i32 [[TMP25]], 0
; DATA-NEXT:    [[TMP27:%.*]] = select i1 [[TMP26]], i64 [[CSA_EXTRACT]], i64 [[II:%.*]]
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[COND_LCSSA:%.*]] = phi i64 [ [[COND:%.*]], [[FOR_BODY]] ], [ [[TMP27]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[IDX_0_LCSSA:%.*]] = phi i64 [ [[II]], [[ENTRY:%.*]] ], [ [[COND_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; DATA-NEXT:    ret i64 [[IDX_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[I_010:%.*]] = phi i64 [ [[INC:%.*]], [[FOR_BODY]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ]
; DATA-NEXT:    [[IDX_09:%.*]] = phi i64 [ [[COND]], [[FOR_BODY]] ], [ [[II]], [[SCALAR_PH]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[I_010]]
; DATA-NEXT:    [[TMP28:%.*]] = load i64, ptr [[ARRAYIDX]], align 8
; DATA-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[I_010]]
; DATA-NEXT:    [[TMP29:%.*]] = load i64, ptr [[ARRAYIDX1]], align 8
; DATA-NEXT:    [[CMP2:%.*]] = icmp sgt i64 [[TMP28]], [[TMP29]]
; DATA-NEXT:    [[COND]] = select i1 [[CMP2]], i64 [[I_010]], i64 [[IDX_09]]
; DATA-NEXT:    [[INC]] = add nuw i64 [[I_010]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INC]], [[N]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP15:![0-9]+]]
;
entry:
  %cmp8.not = icmp eq i64 %n, 0
  br i1 %cmp8.not, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %cond.lcssa = phi i64 [ %cond, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %idx.0.lcssa = phi i64 [ %ii, %entry ], [ %cond.lcssa, %for.cond.cleanup.loopexit ]
  ret i64 %idx.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %i.010 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %idx.09 = phi i64 [ %cond, %for.body ], [ %ii, %for.body.preheader ]
  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %i.010
  %0 = load i64, ptr %arrayidx, align 8
  %arrayidx1 = getelementptr inbounds i64, ptr %b, i64 %i.010
  %1 = load i64, ptr %arrayidx1, align 8
  %cmp2 = icmp sgt i64 %0, %1
  %cond = select i1 %cmp2, i64 %i.010, i64 %idx.09
  %inc = add nuw i64 %i.010, 1
  %exitcond.not = icmp eq i64 %inc, %n
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; uint64_t idx_scalar_dec(int64_t *a, int64_t *b, uint64_t ii, uint64_t n) {
;   uint64_t idx = ii;
;   for (uint64_t i = n; i > 0; --i) // decreasing
;      idx = (a[i - 1] > b[i - 1]) ? i : idx;
;   return idx;
; }
define dso_local i64 @idx_scalar_dec(ptr %a, ptr %b, i64 %ii, i64 %n) {
; EVL-LABEL: @idx_scalar_dec(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP_NOT9:%.*]] = icmp eq i64 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP_NOT9]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], 8
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[N]], 8
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[N]], [[N_MOD_VF]]
; EVL-NEXT:    [[IND_END:%.*]] = sub i64 [[N]], [[N_VEC]]
; EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[N]], i64 0
; EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <4 x i64> [[DOTSPLATINSERT]], <4 x i64> poison, <4 x i32> zeroinitializer
; EVL-NEXT:    [[INDUCTION:%.*]] = add <4 x i64> [[DOTSPLAT]], <i64 0, i64 -1, i64 -2, i64 -3>
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL8:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[VEC_IND:%.*]] = phi <4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <4 x i64> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL9:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[STEP_ADD:%.*]] = add <4 x i64> [[VEC_IND]], <i64 -4, i64 -4, i64 -4, i64 -4>
; EVL-NEXT:    [[TMP0:%.*]] = add <4 x i64> [[VEC_IND]], <i64 -1, i64 -1, i64 -1, i64 -1>
; EVL-NEXT:    [[TMP1:%.*]] = add <4 x i64> [[STEP_ADD]], <i64 -1, i64 -1, i64 -1, i64 -1>
; EVL-NEXT:    [[TMP2:%.*]] = extractelement <4 x i64> [[TMP0]], i32 0
; EVL-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[TMP2]]
; EVL-NEXT:    [[TMP4:%.*]] = extractelement <4 x i64> [[TMP1]], i32 0
; EVL-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[TMP4]]
; EVL-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i64, ptr [[TMP3]], i32 0
; EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP6]], i32 -3
; EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i64, ptr [[TMP3]], i32 -4
; EVL-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i64, ptr [[TMP8]], i32 -3
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i64>, ptr [[TMP7]], align 8
; EVL-NEXT:    [[REVERSE:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; EVL-NEXT:    [[WIDE_LOAD2:%.*]] = load <4 x i64>, ptr [[TMP9]], align 8
; EVL-NEXT:    [[REVERSE3:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD2]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; EVL-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i64, ptr [[B:%.*]], i64 [[TMP2]]
; EVL-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[TMP4]]
; EVL-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i64, ptr [[TMP10]], i32 0
; EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i64, ptr [[TMP12]], i32 -3
; EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i64, ptr [[TMP10]], i32 -4
; EVL-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i64, ptr [[TMP14]], i32 -3
; EVL-NEXT:    [[WIDE_LOAD4:%.*]] = load <4 x i64>, ptr [[TMP13]], align 8
; EVL-NEXT:    [[REVERSE5:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD4]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; EVL-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i64>, ptr [[TMP15]], align 8
; EVL-NEXT:    [[REVERSE7:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD6]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; EVL-NEXT:    [[TMP16:%.*]] = icmp sgt <4 x i64> [[REVERSE]], [[REVERSE5]]
; EVL-NEXT:    [[TMP17:%.*]] = icmp sgt <4 x i64> [[REVERSE3]], [[REVERSE7]]
; EVL-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP16]])
; EVL-NEXT:    [[TMP19:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP17]])
; EVL-NEXT:    [[CSA_MASK_SEL:%.*]] = select i1 [[TMP18]], <4 x i1> [[TMP16]], <4 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_MASK_SEL8]] = select i1 [[TMP19]], <4 x i1> [[TMP17]], <4 x i1> [[CSA_MASK_SEL]]
; EVL-NEXT:    [[CSA_DATA_SEL:%.*]] = select i1 [[TMP18]], <4 x i64> [[VEC_IND]], <4 x i64> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL9]] = select i1 [[TMP19]], <4 x i64> [[STEP_ADD]], <4 x i64> [[CSA_DATA_SEL]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 8
; EVL-NEXT:    [[VEC_IND_NEXT]] = add <4 x i64> [[STEP_ADD]], <i64 -4, i64 -4, i64 -4, i64 -4>
; EVL-NEXT:    [[TMP20:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP20]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP16:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[TMP21:%.*]] = select <4 x i1> [[CSA_MASK_SEL8]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>, <4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP22:%.*]] = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> [[TMP21]])
; EVL-NEXT:    [[TMP23:%.*]] = extractelement <4 x i1> [[CSA_MASK_SEL8]], i64 0
; EVL-NEXT:    [[TMP24:%.*]] = icmp eq i32 [[TMP22]], 0
; EVL-NEXT:    [[TMP25:%.*]] = and i1 [[TMP23]], [[TMP24]]
; EVL-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <4 x i64> [[CSA_DATA_SEL9]], i32 [[TMP26]]
; EVL-NEXT:    [[TMP27:%.*]] = icmp sge i32 [[TMP26]], 0
; EVL-NEXT:    [[TMP28:%.*]] = select i1 [[TMP27]], i64 [[CSA_EXTRACT]], i64 [[II:%.*]]
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[IND_END]], [[MIDDLE_BLOCK]] ], [ [[N]], [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[COND_LCSSA:%.*]] = phi i64 [ [[COND:%.*]], [[FOR_BODY]] ], [ [[TMP28]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[IDX_0_LCSSA:%.*]] = phi i64 [ [[II]], [[ENTRY:%.*]] ], [ [[COND_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; EVL-NEXT:    ret i64 [[IDX_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[I_011:%.*]] = phi i64 [ [[SUB:%.*]], [[FOR_BODY]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ]
; EVL-NEXT:    [[IDX_010:%.*]] = phi i64 [ [[COND]], [[FOR_BODY]] ], [ [[II]], [[SCALAR_PH]] ]
; EVL-NEXT:    [[SUB]] = add i64 [[I_011]], -1
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[SUB]]
; EVL-NEXT:    [[TMP29:%.*]] = load i64, ptr [[ARRAYIDX]], align 8
; EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[SUB]]
; EVL-NEXT:    [[TMP30:%.*]] = load i64, ptr [[ARRAYIDX2]], align 8
; EVL-NEXT:    [[CMP3:%.*]] = icmp sgt i64 [[TMP29]], [[TMP30]]
; EVL-NEXT:    [[COND]] = select i1 [[CMP3]], i64 [[I_011]], i64 [[IDX_010]]
; EVL-NEXT:    [[CMP_NOT:%.*]] = icmp eq i64 [[SUB]], 0
; EVL-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP17:![0-9]+]]
;
; NO-EVL-LABEL: @idx_scalar_dec(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP_NOT9:%.*]] = icmp eq i64 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP_NOT9]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], 8
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[N]], 8
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[N]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[IND_END:%.*]] = sub i64 [[N]], [[N_VEC]]
; NO-EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[N]], i64 0
; NO-EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <4 x i64> [[DOTSPLATINSERT]], <4 x i64> poison, <4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[INDUCTION:%.*]] = add <4 x i64> [[DOTSPLAT]], <i64 0, i64 -1, i64 -2, i64 -3>
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL8:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[VEC_IND:%.*]] = phi <4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <4 x i64> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL9:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[STEP_ADD:%.*]] = add <4 x i64> [[VEC_IND]], <i64 -4, i64 -4, i64 -4, i64 -4>
; NO-EVL-NEXT:    [[TMP0:%.*]] = add <4 x i64> [[VEC_IND]], <i64 -1, i64 -1, i64 -1, i64 -1>
; NO-EVL-NEXT:    [[TMP1:%.*]] = add <4 x i64> [[STEP_ADD]], <i64 -1, i64 -1, i64 -1, i64 -1>
; NO-EVL-NEXT:    [[TMP2:%.*]] = extractelement <4 x i64> [[TMP0]], i32 0
; NO-EVL-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[TMP2]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = extractelement <4 x i64> [[TMP1]], i32 0
; NO-EVL-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[TMP4]]
; NO-EVL-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i64, ptr [[TMP3]], i32 0
; NO-EVL-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP6]], i32 -3
; NO-EVL-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i64, ptr [[TMP3]], i32 -4
; NO-EVL-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i64, ptr [[TMP8]], i32 -3
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i64>, ptr [[TMP7]], align 8
; NO-EVL-NEXT:    [[REVERSE:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; NO-EVL-NEXT:    [[WIDE_LOAD2:%.*]] = load <4 x i64>, ptr [[TMP9]], align 8
; NO-EVL-NEXT:    [[REVERSE3:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD2]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; NO-EVL-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i64, ptr [[B:%.*]], i64 [[TMP2]]
; NO-EVL-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[TMP4]]
; NO-EVL-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i64, ptr [[TMP10]], i32 0
; NO-EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i64, ptr [[TMP12]], i32 -3
; NO-EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i64, ptr [[TMP10]], i32 -4
; NO-EVL-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i64, ptr [[TMP14]], i32 -3
; NO-EVL-NEXT:    [[WIDE_LOAD4:%.*]] = load <4 x i64>, ptr [[TMP13]], align 8
; NO-EVL-NEXT:    [[REVERSE5:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD4]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; NO-EVL-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i64>, ptr [[TMP15]], align 8
; NO-EVL-NEXT:    [[REVERSE7:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD6]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; NO-EVL-NEXT:    [[TMP16:%.*]] = icmp sgt <4 x i64> [[REVERSE]], [[REVERSE5]]
; NO-EVL-NEXT:    [[TMP17:%.*]] = icmp sgt <4 x i64> [[REVERSE3]], [[REVERSE7]]
; NO-EVL-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP16]])
; NO-EVL-NEXT:    [[TMP19:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP17]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL:%.*]] = select i1 [[TMP18]], <4 x i1> [[TMP16]], <4 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_MASK_SEL8]] = select i1 [[TMP19]], <4 x i1> [[TMP17]], <4 x i1> [[CSA_MASK_SEL]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL:%.*]] = select i1 [[TMP18]], <4 x i64> [[VEC_IND]], <4 x i64> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL9]] = select i1 [[TMP19]], <4 x i64> [[STEP_ADD]], <4 x i64> [[CSA_DATA_SEL]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 8
; NO-EVL-NEXT:    [[VEC_IND_NEXT]] = add <4 x i64> [[STEP_ADD]], <i64 -4, i64 -4, i64 -4, i64 -4>
; NO-EVL-NEXT:    [[TMP20:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP20]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP16:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[TMP21:%.*]] = select <4 x i1> [[CSA_MASK_SEL8]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>, <4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP22:%.*]] = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> [[TMP21]])
; NO-EVL-NEXT:    [[TMP23:%.*]] = extractelement <4 x i1> [[CSA_MASK_SEL8]], i64 0
; NO-EVL-NEXT:    [[TMP24:%.*]] = icmp eq i32 [[TMP22]], 0
; NO-EVL-NEXT:    [[TMP25:%.*]] = and i1 [[TMP23]], [[TMP24]]
; NO-EVL-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <4 x i64> [[CSA_DATA_SEL9]], i32 [[TMP26]]
; NO-EVL-NEXT:    [[TMP27:%.*]] = icmp sge i32 [[TMP26]], 0
; NO-EVL-NEXT:    [[TMP28:%.*]] = select i1 [[TMP27]], i64 [[CSA_EXTRACT]], i64 [[II:%.*]]
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[IND_END]], [[MIDDLE_BLOCK]] ], [ [[N]], [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[COND_LCSSA:%.*]] = phi i64 [ [[COND:%.*]], [[FOR_BODY]] ], [ [[TMP28]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[IDX_0_LCSSA:%.*]] = phi i64 [ [[II]], [[ENTRY:%.*]] ], [ [[COND_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; NO-EVL-NEXT:    ret i64 [[IDX_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[I_011:%.*]] = phi i64 [ [[SUB:%.*]], [[FOR_BODY]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ]
; NO-EVL-NEXT:    [[IDX_010:%.*]] = phi i64 [ [[COND]], [[FOR_BODY]] ], [ [[II]], [[SCALAR_PH]] ]
; NO-EVL-NEXT:    [[SUB]] = add i64 [[I_011]], -1
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[SUB]]
; NO-EVL-NEXT:    [[TMP29:%.*]] = load i64, ptr [[ARRAYIDX]], align 8
; NO-EVL-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[SUB]]
; NO-EVL-NEXT:    [[TMP30:%.*]] = load i64, ptr [[ARRAYIDX2]], align 8
; NO-EVL-NEXT:    [[CMP3:%.*]] = icmp sgt i64 [[TMP29]], [[TMP30]]
; NO-EVL-NEXT:    [[COND]] = select i1 [[CMP3]], i64 [[I_011]], i64 [[IDX_010]]
; NO-EVL-NEXT:    [[CMP_NOT:%.*]] = icmp eq i64 [[SUB]], 0
; NO-EVL-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP17:![0-9]+]]
;
; DATA-LABEL: @idx_scalar_dec(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP_NOT9:%.*]] = icmp eq i64 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP_NOT9]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], 8
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[N]], 8
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[N]], [[N_MOD_VF]]
; DATA-NEXT:    [[IND_END:%.*]] = sub i64 [[N]], [[N_VEC]]
; DATA-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[N]], i64 0
; DATA-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <4 x i64> [[DOTSPLATINSERT]], <4 x i64> poison, <4 x i32> zeroinitializer
; DATA-NEXT:    [[INDUCTION:%.*]] = add <4 x i64> [[DOTSPLAT]], <i64 0, i64 -1, i64 -2, i64 -3>
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL8:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[VEC_IND:%.*]] = phi <4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <4 x i64> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL9:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[STEP_ADD:%.*]] = add <4 x i64> [[VEC_IND]], <i64 -4, i64 -4, i64 -4, i64 -4>
; DATA-NEXT:    [[TMP0:%.*]] = add <4 x i64> [[VEC_IND]], <i64 -1, i64 -1, i64 -1, i64 -1>
; DATA-NEXT:    [[TMP1:%.*]] = add <4 x i64> [[STEP_ADD]], <i64 -1, i64 -1, i64 -1, i64 -1>
; DATA-NEXT:    [[TMP2:%.*]] = extractelement <4 x i64> [[TMP0]], i32 0
; DATA-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[TMP2]]
; DATA-NEXT:    [[TMP4:%.*]] = extractelement <4 x i64> [[TMP1]], i32 0
; DATA-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[TMP4]]
; DATA-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i64, ptr [[TMP3]], i32 0
; DATA-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP6]], i32 -3
; DATA-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i64, ptr [[TMP3]], i32 -4
; DATA-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i64, ptr [[TMP8]], i32 -3
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i64>, ptr [[TMP7]], align 8
; DATA-NEXT:    [[REVERSE:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; DATA-NEXT:    [[WIDE_LOAD2:%.*]] = load <4 x i64>, ptr [[TMP9]], align 8
; DATA-NEXT:    [[REVERSE3:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD2]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; DATA-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i64, ptr [[B:%.*]], i64 [[TMP2]]
; DATA-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[TMP4]]
; DATA-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i64, ptr [[TMP10]], i32 0
; DATA-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i64, ptr [[TMP12]], i32 -3
; DATA-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i64, ptr [[TMP10]], i32 -4
; DATA-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i64, ptr [[TMP14]], i32 -3
; DATA-NEXT:    [[WIDE_LOAD4:%.*]] = load <4 x i64>, ptr [[TMP13]], align 8
; DATA-NEXT:    [[REVERSE5:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD4]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; DATA-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i64>, ptr [[TMP15]], align 8
; DATA-NEXT:    [[REVERSE7:%.*]] = shufflevector <4 x i64> [[WIDE_LOAD6]], <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; DATA-NEXT:    [[TMP16:%.*]] = icmp sgt <4 x i64> [[REVERSE]], [[REVERSE5]]
; DATA-NEXT:    [[TMP17:%.*]] = icmp sgt <4 x i64> [[REVERSE3]], [[REVERSE7]]
; DATA-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP16]])
; DATA-NEXT:    [[TMP19:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP17]])
; DATA-NEXT:    [[CSA_MASK_SEL:%.*]] = select i1 [[TMP18]], <4 x i1> [[TMP16]], <4 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_MASK_SEL8]] = select i1 [[TMP19]], <4 x i1> [[TMP17]], <4 x i1> [[CSA_MASK_SEL]]
; DATA-NEXT:    [[CSA_DATA_SEL:%.*]] = select i1 [[TMP18]], <4 x i64> [[VEC_IND]], <4 x i64> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL9]] = select i1 [[TMP19]], <4 x i64> [[STEP_ADD]], <4 x i64> [[CSA_DATA_SEL]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 8
; DATA-NEXT:    [[VEC_IND_NEXT]] = add <4 x i64> [[STEP_ADD]], <i64 -4, i64 -4, i64 -4, i64 -4>
; DATA-NEXT:    [[TMP20:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP20]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP16:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[TMP21:%.*]] = select <4 x i1> [[CSA_MASK_SEL8]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>, <4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP22:%.*]] = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> [[TMP21]])
; DATA-NEXT:    [[TMP23:%.*]] = extractelement <4 x i1> [[CSA_MASK_SEL8]], i64 0
; DATA-NEXT:    [[TMP24:%.*]] = icmp eq i32 [[TMP22]], 0
; DATA-NEXT:    [[TMP25:%.*]] = and i1 [[TMP23]], [[TMP24]]
; DATA-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <4 x i64> [[CSA_DATA_SEL9]], i32 [[TMP26]]
; DATA-NEXT:    [[TMP27:%.*]] = icmp sge i32 [[TMP26]], 0
; DATA-NEXT:    [[TMP28:%.*]] = select i1 [[TMP27]], i64 [[CSA_EXTRACT]], i64 [[II:%.*]]
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[IND_END]], [[MIDDLE_BLOCK]] ], [ [[N]], [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[COND_LCSSA:%.*]] = phi i64 [ [[COND:%.*]], [[FOR_BODY]] ], [ [[TMP28]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[IDX_0_LCSSA:%.*]] = phi i64 [ [[II]], [[ENTRY:%.*]] ], [ [[COND_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; DATA-NEXT:    ret i64 [[IDX_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[I_011:%.*]] = phi i64 [ [[SUB:%.*]], [[FOR_BODY]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ]
; DATA-NEXT:    [[IDX_010:%.*]] = phi i64 [ [[COND]], [[FOR_BODY]] ], [ [[II]], [[SCALAR_PH]] ]
; DATA-NEXT:    [[SUB]] = add i64 [[I_011]], -1
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[SUB]]
; DATA-NEXT:    [[TMP29:%.*]] = load i64, ptr [[ARRAYIDX]], align 8
; DATA-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[SUB]]
; DATA-NEXT:    [[TMP30:%.*]] = load i64, ptr [[ARRAYIDX2]], align 8
; DATA-NEXT:    [[CMP3:%.*]] = icmp sgt i64 [[TMP29]], [[TMP30]]
; DATA-NEXT:    [[COND]] = select i1 [[CMP3]], i64 [[I_011]], i64 [[IDX_010]]
; DATA-NEXT:    [[CMP_NOT:%.*]] = icmp eq i64 [[SUB]], 0
; DATA-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP17:![0-9]+]]
;
entry:
  %cmp.not9 = icmp eq i64 %n, 0
  br i1 %cmp.not9, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %cond.lcssa = phi i64 [ %cond, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %idx.0.lcssa = phi i64 [ %ii, %entry ], [ %cond.lcssa, %for.cond.cleanup.loopexit ]
  ret i64 %idx.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %i.011 = phi i64 [ %sub, %for.body ], [ %n, %for.body.preheader ]
  %idx.010 = phi i64 [ %cond, %for.body ], [ %ii, %for.body.preheader ]
  %sub = add i64 %i.011, -1
  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %sub
  %0 = load i64, ptr %arrayidx, align 8
  %arrayidx2 = getelementptr inbounds i64, ptr %b, i64 %sub
  %1 = load i64, ptr %arrayidx2, align 8
  %cmp3 = icmp sgt i64 %0, %1
  %cond = select i1 %cmp3, i64 %i.011, i64 %idx.010
  %cmp.not = icmp eq i64 %sub, 0
  br i1 %cmp.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; The key part of this function is that the true arm of the select corresponds
; to selecting the initial value, instead of selecting the new value.
; int simple_csa_int_select_neg_cond(int N, int *data) {
;   int t = 0;
;   for (int i = 0; i < N; i++) {
;     if (i != data[i])
;       t = data[i];
;   }
;   return t; // use t
; }
define i32 @simple_csa_int_select_neg_cond(i32 %N, ptr %data) {
; EVL-LABEL: @simple_csa_int_select_neg_cond(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP12]]
; EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; EVL-NEXT:    [[TMP15:%.*]] = zext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; EVL-NEXT:    [[TMP16:%.*]] = icmp eq <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; EVL-NEXT:    [[TMP17:%.*]] = xor <vscale x 4 x i1> [[TMP16]], shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer)
; EVL-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP17]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP18]], <vscale x 4 x i1> [[TMP17]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP18]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; EVL-NEXT:    [[TMP19:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP18:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; EVL-NEXT:    [[TMP20:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; EVL-NEXT:    [[TMP21:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP20]])
; EVL-NEXT:    [[TMP22:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP23:%.*]] = icmp eq i32 [[TMP21]], 0
; EVL-NEXT:    [[TMP24:%.*]] = and i1 [[TMP22]], [[TMP23]]
; EVL-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP25]]
; EVL-NEXT:    [[TMP26:%.*]] = icmp sge i32 [[TMP25]], 0
; EVL-NEXT:    [[TMP27:%.*]] = select i1 [[TMP26]], i32 [[CSA_EXTRACT]], i32 0
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP27]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_010:%.*]] = phi i32 [ 0, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP28:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; EVL-NEXT:    [[TMP29:%.*]] = zext i32 [[TMP28]] to i64
; EVL-NEXT:    [[CMP1_NOT:%.*]] = icmp eq i64 [[INDVARS_IV]], [[TMP29]]
; EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1_NOT]], i32 [[T_010]], i32 [[TMP28]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP19:![0-9]+]]
;
; NO-EVL-LABEL: @simple_csa_int_select_neg_cond(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; NO-EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; NO-EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; NO-EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; NO-EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; NO-EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; NO-EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; NO-EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; NO-EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP12]]
; NO-EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; NO-EVL-NEXT:    [[TMP15:%.*]] = zext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; NO-EVL-NEXT:    [[TMP16:%.*]] = icmp eq <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; NO-EVL-NEXT:    [[TMP17:%.*]] = xor <vscale x 4 x i1> [[TMP16]], shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer)
; NO-EVL-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP17]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP18]], <vscale x 4 x i1> [[TMP17]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP18]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; NO-EVL-NEXT:    [[TMP19:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP18:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; NO-EVL-NEXT:    [[TMP20:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP21:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP20]])
; NO-EVL-NEXT:    [[TMP22:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP23:%.*]] = icmp eq i32 [[TMP21]], 0
; NO-EVL-NEXT:    [[TMP24:%.*]] = and i1 [[TMP22]], [[TMP23]]
; NO-EVL-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP25]]
; NO-EVL-NEXT:    [[TMP26:%.*]] = icmp sge i32 [[TMP25]], 0
; NO-EVL-NEXT:    [[TMP27:%.*]] = select i1 [[TMP26]], i32 [[CSA_EXTRACT]], i32 0
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP27]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; NO-EVL-NEXT:    ret i32 [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_010:%.*]] = phi i32 [ 0, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP28:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; NO-EVL-NEXT:    [[TMP29:%.*]] = zext i32 [[TMP28]] to i64
; NO-EVL-NEXT:    [[CMP1_NOT:%.*]] = icmp eq i64 [[INDVARS_IV]], [[TMP29]]
; NO-EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1_NOT]], i32 [[T_010]], i32 [[TMP28]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP19:![0-9]+]]
;
; DATA-LABEL: @simple_csa_int_select_neg_cond(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 4
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 4
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 4
; DATA-NEXT:    [[TMP6:%.*]] = call <vscale x 4 x i64> @llvm.stepvector.nxv4i64()
; DATA-NEXT:    [[TMP7:%.*]] = add <vscale x 4 x i64> [[TMP6]], zeroinitializer
; DATA-NEXT:    [[TMP8:%.*]] = mul <vscale x 4 x i64> [[TMP7]], shufflevector (<vscale x 4 x i64> insertelement (<vscale x 4 x i64> poison, i64 1, i64 0), <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer)
; DATA-NEXT:    [[INDUCTION:%.*]] = add <vscale x 4 x i64> zeroinitializer, [[TMP8]]
; DATA-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 4
; DATA-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; DATA-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 4 x i64> poison, i64 [[TMP11]], i64 0
; DATA-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 4 x i64> [[DOTSPLATINSERT]], <vscale x 4 x i64> poison, <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 4 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 4 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 4 x i32> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[DATA:%.*]], i64 [[TMP12]]
; DATA-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP13]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 4 x i32>, ptr [[TMP14]], align 4
; DATA-NEXT:    [[TMP15:%.*]] = zext <vscale x 4 x i32> [[WIDE_LOAD]] to <vscale x 4 x i64>
; DATA-NEXT:    [[TMP16:%.*]] = icmp eq <vscale x 4 x i64> [[VEC_IND]], [[TMP15]]
; DATA-NEXT:    [[TMP17:%.*]] = xor <vscale x 4 x i1> [[TMP16]], shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer)
; DATA-NEXT:    [[TMP18:%.*]] = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> [[TMP17]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP18]], <vscale x 4 x i1> [[TMP17]], <vscale x 4 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP18]], <vscale x 4 x i32> [[WIDE_LOAD]], <vscale x 4 x i32> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 4 x i64> [[VEC_IND]], [[DOTSPLAT]]
; DATA-NEXT:    [[TMP19:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP18:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 4 x i32> @llvm.stepvector.nxv4i32()
; DATA-NEXT:    [[TMP20:%.*]] = select <vscale x 4 x i1> [[CSA_MASK_SEL]], <vscale x 4 x i32> [[CSA_STEP]], <vscale x 4 x i32> zeroinitializer
; DATA-NEXT:    [[TMP21:%.*]] = call i32 @llvm.vector.reduce.umax.nxv4i32(<vscale x 4 x i32> [[TMP20]])
; DATA-NEXT:    [[TMP22:%.*]] = extractelement <vscale x 4 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP23:%.*]] = icmp eq i32 [[TMP21]], 0
; DATA-NEXT:    [[TMP24:%.*]] = and i1 [[TMP22]], [[TMP23]]
; DATA-NEXT:    [[TMP25:%.*]] = select i1 [[TMP24]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 4 x i32> [[CSA_DATA_SEL]], i32 [[TMP25]]
; DATA-NEXT:    [[TMP26:%.*]] = icmp sge i32 [[TMP25]], 0
; DATA-NEXT:    [[TMP27:%.*]] = select i1 [[TMP26]], i32 [[CSA_EXTRACT]], i32 0
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi i32 [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP27]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; DATA-NEXT:    ret i32 [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_010:%.*]] = phi i32 [ 0, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[DATA]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP28:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; DATA-NEXT:    [[TMP29:%.*]] = zext i32 [[TMP28]] to i64
; DATA-NEXT:    [[CMP1_NOT:%.*]] = icmp eq i64 [[INDVARS_IV]], [[TMP29]]
; DATA-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1_NOT]], i32 [[T_010]], i32 [[TMP28]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP19:![0-9]+]]
;
entry:
  %cmp9 = icmp sgt i32 %N, 0
  br i1 %cmp9, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %spec.select.lcssa = phi i32 [ %spec.select, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %t.0.lcssa = phi i32 [ 0, %entry ], [ %spec.select.lcssa, %for.cond.cleanup.loopexit ]
  ret i32 %t.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %t.010 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %data, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %1 = zext i32 %0 to i64
  %cmp1.not = icmp eq i64 %indvars.iv, %1
  %spec.select = select i1 %cmp1.not, i32 %t.010, i32 %0
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; This function is generated from the following C/C++ program:
; int *simple_csa_ptr_select(int N, int **data) {
;   int *t = nullptr;
;   for (int i = 0; i < N; i++) {
;     if (i < *data[i])
;       t = data[i];
;   }
;   return t; // use t
; }
define ptr @simple_csa_ptr_select(i32 %N, ptr %data) {
; EVL-LABEL: @simple_csa_ptr_select(
; EVL-NEXT:  entry:
; EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; EVL:       for.body.preheader:
; EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 2
; EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; EVL:       vector.ph:
; EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 2
; EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 2
; EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 2 x i64> @llvm.stepvector.nxv2i64()
; EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 2 x i64> [[TMP6]], zeroinitializer
; EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 2 x i64> [[TMP7]], shufflevector (<vscale x 2 x i64> insertelement (<vscale x 2 x i64> poison, i64 1, i64 0), <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer)
; EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 2 x i64> zeroinitializer, [[TMP8]]
; EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 2
; EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 2 x i64> poison, i64 [[TMP11]], i64 0
; EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 2 x i64> [[DOTSPLATINSERT]], <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
; EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; EVL:       vector.body:
; EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 2 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 2 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 2 x ptr> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds ptr, ptr [[DATA:%.*]], i64 [[TMP12]]
; EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds ptr, ptr [[TMP13]], i32 0
; EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 2 x ptr>, ptr [[TMP14]], align 8
; EVL-NEXT:    [[WIDE_MASKED_GATHER:%.*]] = call <vscale x 2 x i32> @llvm.masked.gather.nxv2i32.nxv2p0(<vscale x 2 x ptr> [[WIDE_LOAD]], i32 4, <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer), <vscale x 2 x i32> poison)
; EVL-NEXT:    [[TMP15:%.*]] = sext <vscale x 2 x i32> [[WIDE_MASKED_GATHER]] to <vscale x 2 x i64>
; EVL-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 2 x i64> [[VEC_IND]], [[TMP15]]
; EVL-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> [[TMP16]])
; EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 2 x i1> [[TMP16]], <vscale x 2 x i1> [[CSA_MASK_PHI]]
; EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 2 x ptr> [[WIDE_LOAD]], <vscale x 2 x ptr> [[CSA_DATA_PHI]]
; EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 2 x i64> [[VEC_IND]], [[DOTSPLAT]]
; EVL-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[TMP18]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP20:![0-9]+]]
; EVL:       middle.block:
; EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 2 x i32> @llvm.stepvector.nxv2i32()
; EVL-NEXT:    [[TMP19:%.*]] = select <vscale x 2 x i1> [[CSA_MASK_SEL]], <vscale x 2 x i32> [[CSA_STEP]], <vscale x 2 x i32> zeroinitializer
; EVL-NEXT:    [[TMP20:%.*]] = call i32 @llvm.vector.reduce.umax.nxv2i32(<vscale x 2 x i32> [[TMP19]])
; EVL-NEXT:    [[TMP21:%.*]] = extractelement <vscale x 2 x i1> [[CSA_MASK_SEL]], i64 0
; EVL-NEXT:    [[TMP22:%.*]] = icmp eq i32 [[TMP20]], 0
; EVL-NEXT:    [[TMP23:%.*]] = and i1 [[TMP21]], [[TMP22]]
; EVL-NEXT:    [[TMP24:%.*]] = select i1 [[TMP23]], i32 0, i32 -1
; EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 2 x ptr> [[CSA_DATA_SEL]], i32 [[TMP24]]
; EVL-NEXT:    [[TMP25:%.*]] = icmp sge i32 [[TMP24]], 0
; EVL-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], ptr [[CSA_EXTRACT]], ptr null
; EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; EVL:       scalar.ph:
; EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; EVL-NEXT:    br label [[FOR_BODY:%.*]]
; EVL:       for.cond.cleanup.loopexit:
; EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi ptr [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP26]], [[MIDDLE_BLOCK]] ]
; EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; EVL:       for.cond.cleanup:
; EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi ptr [ null, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; EVL-NEXT:    ret ptr [[T_0_LCSSA]]
; EVL:       for.body:
; EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; EVL-NEXT:    [[T_010:%.*]] = phi ptr [ null, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds ptr, ptr [[DATA]], i64 [[INDVARS_IV]]
; EVL-NEXT:    [[TMP27:%.*]] = load ptr, ptr [[ARRAYIDX]], align 8
; EVL-NEXT:    [[TMP28:%.*]] = load i32, ptr [[TMP27]], align 4
; EVL-NEXT:    [[TMP29:%.*]] = sext i32 [[TMP28]] to i64
; EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP29]]
; EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], ptr [[TMP27]], ptr [[T_010]]
; EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP21:![0-9]+]]
;
; NO-EVL-LABEL: @simple_csa_ptr_select(
; NO-EVL-NEXT:  entry:
; NO-EVL-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; NO-EVL-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; NO-EVL:       for.body.preheader:
; NO-EVL-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; NO-EVL-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 2
; NO-EVL-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; NO-EVL-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; NO-EVL:       vector.ph:
; NO-EVL-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 2
; NO-EVL-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; NO-EVL-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; NO-EVL-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 2
; NO-EVL-NEXT:    [[TMP6:%.*]] = call <vscale x 2 x i64> @llvm.stepvector.nxv2i64()
; NO-EVL-NEXT:    [[TMP7:%.*]] = add <vscale x 2 x i64> [[TMP6]], zeroinitializer
; NO-EVL-NEXT:    [[TMP8:%.*]] = mul <vscale x 2 x i64> [[TMP7]], shufflevector (<vscale x 2 x i64> insertelement (<vscale x 2 x i64> poison, i64 1, i64 0), <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer)
; NO-EVL-NEXT:    [[INDUCTION:%.*]] = add <vscale x 2 x i64> zeroinitializer, [[TMP8]]
; NO-EVL-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; NO-EVL-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 2
; NO-EVL-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; NO-EVL-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 2 x i64> poison, i64 [[TMP11]], i64 0
; NO-EVL-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 2 x i64> [[DOTSPLATINSERT]], <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
; NO-EVL-NEXT:    br label [[VECTOR_BODY:%.*]]
; NO-EVL:       vector.body:
; NO-EVL-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 2 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 2 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 2 x ptr> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; NO-EVL-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; NO-EVL-NEXT:    [[TMP13:%.*]] = getelementptr inbounds ptr, ptr [[DATA:%.*]], i64 [[TMP12]]
; NO-EVL-NEXT:    [[TMP14:%.*]] = getelementptr inbounds ptr, ptr [[TMP13]], i32 0
; NO-EVL-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 2 x ptr>, ptr [[TMP14]], align 8
; NO-EVL-NEXT:    [[WIDE_MASKED_GATHER:%.*]] = call <vscale x 2 x i32> @llvm.masked.gather.nxv2i32.nxv2p0(<vscale x 2 x ptr> [[WIDE_LOAD]], i32 4, <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer), <vscale x 2 x i32> poison)
; NO-EVL-NEXT:    [[TMP15:%.*]] = sext <vscale x 2 x i32> [[WIDE_MASKED_GATHER]] to <vscale x 2 x i64>
; NO-EVL-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 2 x i64> [[VEC_IND]], [[TMP15]]
; NO-EVL-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> [[TMP16]])
; NO-EVL-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 2 x i1> [[TMP16]], <vscale x 2 x i1> [[CSA_MASK_PHI]]
; NO-EVL-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 2 x ptr> [[WIDE_LOAD]], <vscale x 2 x ptr> [[CSA_DATA_PHI]]
; NO-EVL-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; NO-EVL-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 2 x i64> [[VEC_IND]], [[DOTSPLAT]]
; NO-EVL-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[TMP18]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP20:![0-9]+]]
; NO-EVL:       middle.block:
; NO-EVL-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 2 x i32> @llvm.stepvector.nxv2i32()
; NO-EVL-NEXT:    [[TMP19:%.*]] = select <vscale x 2 x i1> [[CSA_MASK_SEL]], <vscale x 2 x i32> [[CSA_STEP]], <vscale x 2 x i32> zeroinitializer
; NO-EVL-NEXT:    [[TMP20:%.*]] = call i32 @llvm.vector.reduce.umax.nxv2i32(<vscale x 2 x i32> [[TMP19]])
; NO-EVL-NEXT:    [[TMP21:%.*]] = extractelement <vscale x 2 x i1> [[CSA_MASK_SEL]], i64 0
; NO-EVL-NEXT:    [[TMP22:%.*]] = icmp eq i32 [[TMP20]], 0
; NO-EVL-NEXT:    [[TMP23:%.*]] = and i1 [[TMP21]], [[TMP22]]
; NO-EVL-NEXT:    [[TMP24:%.*]] = select i1 [[TMP23]], i32 0, i32 -1
; NO-EVL-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 2 x ptr> [[CSA_DATA_SEL]], i32 [[TMP24]]
; NO-EVL-NEXT:    [[TMP25:%.*]] = icmp sge i32 [[TMP24]], 0
; NO-EVL-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], ptr [[CSA_EXTRACT]], ptr null
; NO-EVL-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; NO-EVL-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; NO-EVL:       scalar.ph:
; NO-EVL-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; NO-EVL-NEXT:    br label [[FOR_BODY:%.*]]
; NO-EVL:       for.cond.cleanup.loopexit:
; NO-EVL-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi ptr [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP26]], [[MIDDLE_BLOCK]] ]
; NO-EVL-NEXT:    br label [[FOR_COND_CLEANUP]]
; NO-EVL:       for.cond.cleanup:
; NO-EVL-NEXT:    [[T_0_LCSSA:%.*]] = phi ptr [ null, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; NO-EVL-NEXT:    ret ptr [[T_0_LCSSA]]
; NO-EVL:       for.body:
; NO-EVL-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[T_010:%.*]] = phi ptr [ null, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; NO-EVL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds ptr, ptr [[DATA]], i64 [[INDVARS_IV]]
; NO-EVL-NEXT:    [[TMP27:%.*]] = load ptr, ptr [[ARRAYIDX]], align 8
; NO-EVL-NEXT:    [[TMP28:%.*]] = load i32, ptr [[TMP27]], align 4
; NO-EVL-NEXT:    [[TMP29:%.*]] = sext i32 [[TMP28]] to i64
; NO-EVL-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP29]]
; NO-EVL-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], ptr [[TMP27]], ptr [[T_010]]
; NO-EVL-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; NO-EVL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; NO-EVL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP21:![0-9]+]]
;
; DATA-LABEL: @simple_csa_ptr_select(
; DATA-NEXT:  entry:
; DATA-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; DATA-NEXT:    br i1 [[CMP9]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; DATA:       for.body.preheader:
; DATA-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; DATA-NEXT:    [[TMP0:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP1:%.*]] = mul i64 [[TMP0]], 2
; DATA-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], [[TMP1]]
; DATA-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; DATA:       vector.ph:
; DATA-NEXT:    [[TMP2:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP3:%.*]] = mul i64 [[TMP2]], 2
; DATA-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], [[TMP3]]
; DATA-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; DATA-NEXT:    [[TMP4:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP5:%.*]] = mul i64 [[TMP4]], 2
; DATA-NEXT:    [[TMP6:%.*]] = call <vscale x 2 x i64> @llvm.stepvector.nxv2i64()
; DATA-NEXT:    [[TMP7:%.*]] = add <vscale x 2 x i64> [[TMP6]], zeroinitializer
; DATA-NEXT:    [[TMP8:%.*]] = mul <vscale x 2 x i64> [[TMP7]], shufflevector (<vscale x 2 x i64> insertelement (<vscale x 2 x i64> poison, i64 1, i64 0), <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer)
; DATA-NEXT:    [[INDUCTION:%.*]] = add <vscale x 2 x i64> zeroinitializer, [[TMP8]]
; DATA-NEXT:    [[TMP9:%.*]] = call i64 @llvm.vscale.i64()
; DATA-NEXT:    [[TMP10:%.*]] = mul i64 [[TMP9]], 2
; DATA-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]]
; DATA-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <vscale x 2 x i64> poison, i64 [[TMP11]], i64 0
; DATA-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <vscale x 2 x i64> [[DOTSPLATINSERT]], <vscale x 2 x i64> poison, <vscale x 2 x i32> zeroinitializer
; DATA-NEXT:    br label [[VECTOR_BODY:%.*]]
; DATA:       vector.body:
; DATA-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_MASK_PHI:%.*]] = phi <vscale x 2 x i1> [ zeroinitializer, [[VECTOR_PH]] ], [ [[CSA_MASK_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[VEC_IND:%.*]] = phi <vscale x 2 x i64> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[CSA_DATA_PHI:%.*]] = phi <vscale x 2 x ptr> [ poison, [[VECTOR_PH]] ], [ [[CSA_DATA_SEL:%.*]], [[VECTOR_BODY]] ]
; DATA-NEXT:    [[TMP12:%.*]] = add i64 [[INDEX]], 0
; DATA-NEXT:    [[TMP13:%.*]] = getelementptr inbounds ptr, ptr [[DATA:%.*]], i64 [[TMP12]]
; DATA-NEXT:    [[TMP14:%.*]] = getelementptr inbounds ptr, ptr [[TMP13]], i32 0
; DATA-NEXT:    [[WIDE_LOAD:%.*]] = load <vscale x 2 x ptr>, ptr [[TMP14]], align 8
; DATA-NEXT:    [[WIDE_MASKED_GATHER:%.*]] = call <vscale x 2 x i32> @llvm.masked.gather.nxv2i32.nxv2p0(<vscale x 2 x ptr> [[WIDE_LOAD]], i32 4, <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer), <vscale x 2 x i32> poison)
; DATA-NEXT:    [[TMP15:%.*]] = sext <vscale x 2 x i32> [[WIDE_MASKED_GATHER]] to <vscale x 2 x i64>
; DATA-NEXT:    [[TMP16:%.*]] = icmp slt <vscale x 2 x i64> [[VEC_IND]], [[TMP15]]
; DATA-NEXT:    [[TMP17:%.*]] = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> [[TMP16]])
; DATA-NEXT:    [[CSA_MASK_SEL]] = select i1 [[TMP17]], <vscale x 2 x i1> [[TMP16]], <vscale x 2 x i1> [[CSA_MASK_PHI]]
; DATA-NEXT:    [[CSA_DATA_SEL]] = select i1 [[TMP17]], <vscale x 2 x ptr> [[WIDE_LOAD]], <vscale x 2 x ptr> [[CSA_DATA_PHI]]
; DATA-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], [[TMP5]]
; DATA-NEXT:    [[VEC_IND_NEXT]] = add <vscale x 2 x i64> [[VEC_IND]], [[DOTSPLAT]]
; DATA-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[TMP18]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP20:![0-9]+]]
; DATA:       middle.block:
; DATA-NEXT:    [[CSA_STEP:%.*]] = call <vscale x 2 x i32> @llvm.stepvector.nxv2i32()
; DATA-NEXT:    [[TMP19:%.*]] = select <vscale x 2 x i1> [[CSA_MASK_SEL]], <vscale x 2 x i32> [[CSA_STEP]], <vscale x 2 x i32> zeroinitializer
; DATA-NEXT:    [[TMP20:%.*]] = call i32 @llvm.vector.reduce.umax.nxv2i32(<vscale x 2 x i32> [[TMP19]])
; DATA-NEXT:    [[TMP21:%.*]] = extractelement <vscale x 2 x i1> [[CSA_MASK_SEL]], i64 0
; DATA-NEXT:    [[TMP22:%.*]] = icmp eq i32 [[TMP20]], 0
; DATA-NEXT:    [[TMP23:%.*]] = and i1 [[TMP21]], [[TMP22]]
; DATA-NEXT:    [[TMP24:%.*]] = select i1 [[TMP23]], i32 0, i32 -1
; DATA-NEXT:    [[CSA_EXTRACT:%.*]] = extractelement <vscale x 2 x ptr> [[CSA_DATA_SEL]], i32 [[TMP24]]
; DATA-NEXT:    [[TMP25:%.*]] = icmp sge i32 [[TMP24]], 0
; DATA-NEXT:    [[TMP26:%.*]] = select i1 [[TMP25]], ptr [[CSA_EXTRACT]], ptr null
; DATA-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; DATA-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; DATA:       scalar.ph:
; DATA-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; DATA-NEXT:    br label [[FOR_BODY:%.*]]
; DATA:       for.cond.cleanup.loopexit:
; DATA-NEXT:    [[SPEC_SELECT_LCSSA:%.*]] = phi ptr [ [[SPEC_SELECT:%.*]], [[FOR_BODY]] ], [ [[TMP26]], [[MIDDLE_BLOCK]] ]
; DATA-NEXT:    br label [[FOR_COND_CLEANUP]]
; DATA:       for.cond.cleanup:
; DATA-NEXT:    [[T_0_LCSSA:%.*]] = phi ptr [ null, [[ENTRY:%.*]] ], [ [[SPEC_SELECT_LCSSA]], [[FOR_COND_CLEANUP_LOOPEXIT]] ]
; DATA-NEXT:    ret ptr [[T_0_LCSSA]]
; DATA:       for.body:
; DATA-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; DATA-NEXT:    [[T_010:%.*]] = phi ptr [ null, [[SCALAR_PH]] ], [ [[SPEC_SELECT]], [[FOR_BODY]] ]
; DATA-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds ptr, ptr [[DATA]], i64 [[INDVARS_IV]]
; DATA-NEXT:    [[TMP27:%.*]] = load ptr, ptr [[ARRAYIDX]], align 8
; DATA-NEXT:    [[TMP28:%.*]] = load i32, ptr [[TMP27]], align 4
; DATA-NEXT:    [[TMP29:%.*]] = sext i32 [[TMP28]] to i64
; DATA-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[INDVARS_IV]], [[TMP29]]
; DATA-NEXT:    [[SPEC_SELECT]] = select i1 [[CMP1]], ptr [[TMP27]], ptr [[T_010]]
; DATA-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; DATA-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; DATA-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP21:![0-9]+]]
;
entry:
  %cmp9 = icmp sgt i32 %N, 0
  br i1 %cmp9, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:
  %spec.select.lcssa = phi ptr [ %spec.select, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:
  %t.0.lcssa = phi ptr [ null, %entry ], [ %spec.select.lcssa, %for.cond.cleanup.loopexit ]
  ret ptr %t.0.lcssa

for.body:
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %t.010 = phi ptr [ null, %for.body.preheader ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds ptr, ptr %data, i64 %indvars.iv
  %0 = load ptr, ptr %arrayidx, align 8
  %1 = load i32, ptr %0, align 4
  %2 = sext i32 %1 to i64
  %cmp1 = icmp slt i64 %indvars.iv, %2
  %spec.select = select i1 %cmp1, ptr %0, ptr %t.010
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}
