; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s --mtriple=x86_64 --passes=atomic-expand -S -o - | FileCheck %s

define float @load_atomic_float(ptr %src) {
; CHECK-LABEL: define float @load_atomic_float(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load atomic i32, ptr [[SRC]] acquire, align 4
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 [[TMP1]] to float
; CHECK-NEXT:    ret float [[TMP2]]
;
  %ret = load atomic float, ptr %src acquire, align 4
  ret float %ret
}

define <1 x float> @load_atomic_vector_float1(ptr %src) {
; CHECK-LABEL: define <1 x float> @load_atomic_vector_float1(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load atomic i32, ptr [[SRC]] acquire, align 4
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 [[TMP1]] to <1 x float>
; CHECK-NEXT:    ret <1 x float> [[TMP2]]
;
  %ret = load atomic <1 x float>, ptr %src acquire, align 4
  ret <1 x float> %ret
}

define <2 x float> @load_atomic_vector_float2(ptr %src) {
; CHECK-LABEL: define <2 x float> @load_atomic_vector_float2(
; CHECK-SAME: ptr [[SRC:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = alloca <2 x float>, align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[TMP1]])
; CHECK-NEXT:    call void @__atomic_load(i64 8, ptr [[SRC]], ptr [[TMP1]], i32 2)
; CHECK-NEXT:    [[TMP2:%.*]] = load <2 x float>, ptr [[TMP1]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[TMP1]])
; CHECK-NEXT:    ret <2 x float> [[TMP2]]
;
  %ret = load atomic <2 x float>, ptr %src acquire, align 4
  ret <2 x float> %ret
}
