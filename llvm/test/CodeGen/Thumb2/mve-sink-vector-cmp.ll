; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=thumbv8.1m.main -mattr=+mve < %s | FileCheck %s

define arm_aapcs_vfpcc <4 x i32> @no_sink_simple(<4 x i32> %a, <4 x i32> %b, i1 %c, ptr %p) {
; CHECK-LABEL: no_sink_simple:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    lsls r0, r0, #31
; CHECK-NEXT:    beq .LBB0_2
; CHECK-NEXT:  @ %bb.1: @ %s
; CHECK-NEXT:    vcmp.s32 gt, q1, q0
; CHECK-NEXT:    vmov.i32 q1, #0x0
; CHECK-NEXT:    vpsel q0, q0, q1
; CHECK-NEXT:    vstrw.32 q0, [r1]
; CHECK-NEXT:    bx lr
; CHECK-NEXT:  .LBB0_2: @ %t
; CHECK-NEXT:    vcmp.s32 gt, q1, q0
; CHECK-NEXT:    vmov.i32 q0, #0x0
; CHECK-NEXT:    vpsel q0, q1, q0
; CHECK-NEXT:    bx lr
  %d = icmp slt <4 x i32> %a, %b
  br i1 %c, label %s, label %t

s:
  %s1 = select <4 x i1> %d, <4 x i32> %a, <4 x i32> zeroinitializer
  store <4 x i32> %s1, ptr %p
  ret <4 x i32> %s1

t:
  %s2 = select <4 x i1> %d, <4 x i32> %b, <4 x i32> zeroinitializer
  ret <4 x i32> %s2
}

define arm_aapcs_vfpcc void @vector_loop_with_icmp(ptr nocapture noundef writeonly %dest) {
; CHECK-LABEL: vector_loop_with_icmp:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    push {r7, lr}
; CHECK-NEXT:    vpush {d8, d9}
; CHECK-NEXT:    adr r1, .LCPI1_0
; CHECK-NEXT:    vmov.i32 q1, #0xf
; CHECK-NEXT:    vldrw.u32 q0, [r1]
; CHECK-NEXT:    movs r1, #0
; CHECK-NEXT:    mov.w lr, #1
; CHECK-NEXT:    vmov.i32 q2, #0xf
; CHECK-NEXT:    vmov.i32 q3, #0xf
; CHECK-NEXT:    vmov.i32 q4, #0xf
; CHECK-NEXT:    mov.w r12, #4
; CHECK-NEXT:    movs r3, #0
; CHECK-NEXT:  .LBB1_1: @ %vector.body
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    vcmp.u32 hi, q1, q0
; CHECK-NEXT:    vmrs r2, p0
; CHECK-NEXT:    vcmp.u32 hi, q2, q0
; CHECK-NEXT:    lsls r2, r2, #31
; CHECK-NEXT:    it ne
; CHECK-NEXT:    strne.w lr, [r0, r1, lsl #2]
; CHECK-NEXT:    vmrs r2, p0
; CHECK-NEXT:    vcmp.u32 hi, q3, q0
; CHECK-NEXT:    lsrs r2, r2, #4
; CHECK-NEXT:    lsls r2, r2, #31
; CHECK-NEXT:    itt ne
; CHECK-NEXT:    orrne r2, r1, #1
; CHECK-NEXT:    strne.w lr, [r0, r2, lsl #2]
; CHECK-NEXT:    vmrs r2, p0
; CHECK-NEXT:    vcmp.u32 hi, q4, q0
; CHECK-NEXT:    vadd.i32 q0, q0, r12
; CHECK-NEXT:    lsrs r2, r2, #8
; CHECK-NEXT:    lsls r2, r2, #31
; CHECK-NEXT:    itt ne
; CHECK-NEXT:    orrne r2, r1, #2
; CHECK-NEXT:    strne.w lr, [r0, r2, lsl #2]
; CHECK-NEXT:    vmrs r2, p0
; CHECK-NEXT:    lsrs r2, r2, #12
; CHECK-NEXT:    lsls r2, r2, #31
; CHECK-NEXT:    itt ne
; CHECK-NEXT:    orrne r2, r1, #3
; CHECK-NEXT:    strne.w lr, [r0, r2, lsl #2]
; CHECK-NEXT:    adds r1, #4
; CHECK-NEXT:    adc r3, r3, #0
; CHECK-NEXT:    eor r2, r1, #16
; CHECK-NEXT:    orrs r2, r3
; CHECK-NEXT:    bne .LBB1_1
; CHECK-NEXT:  @ %bb.2: @ %for.cond.cleanup
; CHECK-NEXT:    vpop {d8, d9}
; CHECK-NEXT:    pop {r7, pc}
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  @ %bb.3:
; CHECK-NEXT:  .LCPI1_0:
; CHECK-NEXT:    .long 0 @ 0x0
; CHECK-NEXT:    .long 1 @ 0x1
; CHECK-NEXT:    .long 2 @ 0x2
; CHECK-NEXT:    .long 3 @ 0x3
entry:
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %entry ], [ %index.next, %pred.store.continue18 ]
  %vec.ind = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, %entry ], [ %vec.ind.next, %pred.store.continue18 ]
  %0 = icmp ult <4 x i32> %vec.ind, <i32 15, i32 15, i32 15, i32 15>
  %1 = extractelement <4 x i1> %0, i64 0
  br i1 %1, label %pred.store.if, label %pred.store.continue

pred.store.if:
  %2 = getelementptr inbounds i32, ptr %dest, i64 %index
  store i32 1, ptr %2, align 4
  br label %pred.store.continue

pred.store.continue:
  %3 = extractelement <4 x i1> %0, i64 1
  br i1 %3, label %pred.store.if5, label %pred.store.continue6

pred.store.if5:
  %4 = or disjoint i64 %index, 1
  %5 = getelementptr inbounds i32, ptr %dest, i64 %4
  store i32 1, ptr %5, align 4
  br label %pred.store.continue6

pred.store.continue6:
  %6 = extractelement <4 x i1> %0, i64 2
  br i1 %6, label %pred.store.if7, label %pred.store.continue8

pred.store.if7:
  %7 = or disjoint i64 %index, 2
  %8 = getelementptr inbounds i32, ptr %dest, i64 %7
  store i32 1, ptr %8, align 4
  br label %pred.store.continue8

pred.store.continue8:
  %9 = extractelement <4 x i1> %0, i64 3
  br i1 %9, label %pred.store.if9, label %pred.store.continue18

pred.store.if9:
  %10 = or disjoint i64 %index, 3
  %11 = getelementptr inbounds i32, ptr %dest, i64 %10
  store i32 1, ptr %11, align 4
  br label %pred.store.continue18

pred.store.continue18:
  %index.next = add i64 %index, 4
  %vec.ind.next = add <4 x i32> %vec.ind, <i32 4, i32 4, i32 4, i32 4>
  %24 = icmp eq i64 %index.next, 16
  br i1 %24, label %for.cond.cleanup, label %vector.body

for.cond.cleanup:
  ret void
}
