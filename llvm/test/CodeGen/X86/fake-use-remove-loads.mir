# Ensure that loads into FAKE_USEs are correctly removed by the
# remove-loads-into-fake-uses pass.
# RUN: llc -run-pass remove-loads-into-fake-uses -mtriple=x86_64-unknown-linux -debug-only=remove-loads-into-fake-uses 2>&1 -o - %s | FileCheck %s --implicit-check-not=DELETING
# REQUIRES: asserts
#
## We ensure that the load into the FAKE_USE is removed, along with the FAKE_USE
## itself, even when the FAKE_USE is for a subregister of the move, and that we
## correctly handle situations where FAKE_USE has additional `killed` operands
## added by other passes.

# CHECK: DELETING: renamable $rax = MOV64rm $rbp
# CHECK: DELETING: FAKE_USE renamable $eax

## Also verify that the store to the stack slot still exists.

# CHECK-LABEL: bb.0:
# CHECK: MOV64mr $rbp, 1, $noreg, -48, $noreg, killed renamable $rax :: (store (s64) into %stack.0)

## Finally, verify that when the register has a use between the restore and the
## FAKE_USE, we do not delete the load or fake use.

# CHECK: renamable $r11 = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (load (s64) from %stack.1)
# CHECK: renamable $r12d = XOR32rr $r12d, $r11d, implicit-def dead $eflags
# CHECK: FAKE_USE killed renamable $r11d


---
name:            _ZN1g1jEv
alignment:       16
tracksRegLiveness: true
noPhis:          true
noVRegs:         true
hasFakeUses:     true
tracksDebugUserValues: true
liveins:
  - { reg: '$rdi', virtual-reg: '' }
  - { reg: '$esi', virtual-reg: '' }
  - { reg: '$rdx', virtual-reg: '' }
frameInfo:
  isCalleeSavedInfoValid: true
stack:
  - { id: 0, name: '', type: spill-slot, offset: -8, size: 8, alignment: 8, 
      stack-id: default, callee-saved-register: '', callee-saved-restored: true, 
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 1, name: '', type: spill-slot, offset: -16, size: 8, alignment: 8, 
      stack-id: default, callee-saved-register: '', callee-saved-restored: true, 
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
body:             |
  bb.0:
    liveins: $esi, $rdi, $rdx, $r15, $r14, $r13, $r12, $r11, $rbx

    $rbx = MOV64rr $rdx
    $r14d = MOV32rr $esi
    $r15 = MOV64rr $rdi
    renamable $r12d = XOR32rr undef $r12d, undef $r12d, implicit-def dead $eflags, implicit-def $r12
    renamable $eax = XOR32rr undef $eax, undef $eax, implicit-def dead $eflags, implicit-def $rax
    MOV64mr $rbp, 1, $noreg, -48, $noreg, killed renamable $rax :: (store (s64) into %stack.0)
    MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $r11 :: (store (s64) into %stack.1)
    renamable $eax = XOR32rr undef $eax, undef $eax, implicit-def dead $eflags
    $r13d = MOV32rr killed $eax
    $rdi = MOV64rr $r15
    CALL64r renamable $r12, csr_64, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
    dead renamable $eax = MOV32rm renamable $rbx, 1, $noreg, 0, $noreg
    renamable $eax = MOV32ri 1
    TEST8ri renamable $r14b, 1, implicit-def $eflags
    renamable $rax = MOV64rm $rbp, 1, $noreg, -48, $noreg :: (load (s64) from %stack.0)
    FAKE_USE renamable $eax, implicit killed $rax
    renamable $r11 = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (load (s64) from %stack.1)
    renamable $r12d = XOR32rr $r12d, $r11d, implicit-def dead $eflags
    FAKE_USE killed renamable $r11d
    TEST32rr killed renamable $r13d, renamable $r13d, implicit-def $eflags
    RET64

...
