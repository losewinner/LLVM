; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=instsimplify -S %s | FileCheck %s

define i32 @gt_sub_nsw(i32 %x, i32 %y) {
; CHECK-LABEL: define i32 @gt_sub_nsw(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp samesign ugt i32 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[SUB]], 1
; CHECK-NEXT:    ret i32 [[ADD]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    ret i32 0
;
entry:
  %cmp = icmp samesign ugt i32 %x, %y             ; x>y ? abs (x-y+1): 0
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %sub = sub nsw i32 %x, %y
  %add = add nsw i32 %sub, 1
  %neg = xor i32 %sub, -1                         ; sub nsw i32 0, %add
  %abscond = icmp samesign ult i32 %sub, -1
  %abs = select i1 %abscond, i32 %neg, i32 %add
  ret i32 %abs

cond.end:                                         ; preds = %entry, %cond.true
  ret i32 0
}

define i32 @ge_sub_nsw(i32 %x, i32 %y) {
; CHECK-LABEL: define i32 @ge_sub_nsw(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp samesign uge i32 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[SUB]], 1
; CHECK-NEXT:    ret i32 [[ADD]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    ret i32 0
;
entry:
  %cmp = icmp samesign uge i32 %x, %y             ; x>=y ? abs (x-y+1): 0
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %sub = sub nsw i32 %x, %y
  %add = add nsw i32 %sub, 1
  %neg = xor i32 %sub, -1                         ; sub nsw i32 0, %add
  %abscond = icmp samesign ult i32 %sub, -1
  %abs = select i1 %abscond, i32 %neg, i32 %add
  ret i32 %abs

cond.end:                                         ; preds = %entry, %cond.true
  ret i32 0
}

define i8 @gt_sub_no_nsw(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @gt_sub_no_nsw(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp samesign ugt i8 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[SUB]], 1
; CHECK-NEXT:    [[NEG:%.*]] = xor i8 [[SUB]], -1
; CHECK-NEXT:    [[ABSCOND:%.*]] = icmp samesign ult i8 [[SUB]], -1
; CHECK-NEXT:    [[ABS:%.*]] = select i1 [[ABSCOND]], i8 [[NEG]], i8 [[ADD]]
; CHECK-NEXT:    ret i8 [[ABS]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %cmp = icmp samesign ugt i8 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %sub = sub i8 %x, %y
  %add = add i8 %sub, 1
  %neg = xor i8 %sub, -1
  %abscond = icmp samesign ult i8 %sub, -1
  %abs = select i1 %abscond, i8 %neg, i8 %add
  ret i8 %abs

cond.end:                                         ; preds = %entry, %cond.true
  ret i8 0
}

define i8 @ugt_sub_nsw(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @ugt_sub_nsw(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i8 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[SUB]], 1
; CHECK-NEXT:    [[NEG:%.*]] = xor i8 [[SUB]], -1
; CHECK-NEXT:    [[ABSCOND:%.*]] = icmp ult i8 [[SUB]], -1
; CHECK-NEXT:    [[ABS:%.*]] = select i1 [[ABSCOND]], i8 [[NEG]], i8 [[ADD]]
; CHECK-NEXT:    ret i8 [[ABS]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %cmp = icmp ugt i8 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %sub = sub i8 %x, %y
  %add = add i8 %sub, 1
  %neg = xor i8 %sub, -1
  %abscond = icmp ult i8 %sub, -1
  %abs = select i1 %abscond, i8 %neg, i8 %add
  ret i8 %abs

cond.end:                                         ; preds = %entry, %cond.true
  ret i8 0
}

define i32 @lt_sub_nsw(i32 %x, i32 %y) {
; CHECK-LABEL: define i32 @lt_sub_nsw(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp samesign ult i32 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[NEG:%.*]] = add nsw i32 [[SUB]], 1
; CHECK-NEXT:    ret i32 [[NEG]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    ret i32 0
;
entry:
  %cmp = icmp samesign ult i32 %x, %y             ; x<y ? abs (x-y+1): 0
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %sub = sub nsw i32 %x, %y
  %add = add nsw i32 %sub, 1
  %neg = xor i32 %sub, -1                         ; sub nsw i32 0, %add
  %abscond = icmp samesign ugt i32 %sub, -1
  %abs = select i1 %abscond, i32 %neg, i32 %add
  ret i32 %abs

cond.end:                                         ; preds = %entry, %cond.true
  ret i32 0
}

define i32 @le_sub_nsw(i32 %x, i32 %y) {
; CHECK-LABEL: define i32 @le_sub_nsw(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp samesign ule i32 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[SUB]], 1
; CHECK-NEXT:    ret i32 [[ADD]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    ret i32 0
;
entry:
  %cmp = icmp samesign ule i32 %x, %y             ; x<=y ? abs (x-y+1): 0
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %sub = sub nsw i32 %x, %y
  %add = add nsw i32 %sub, 1
  %neg = xor i32 %sub, -1                         ; sub nsw i32 0, %add
  %abscond = icmp samesign ugt i32 %sub, -1
  %abs = select i1 %abscond, i32 %neg, i32 %add
  ret i32 %abs

cond.end:                                         ; preds = %entry, %cond.true
  ret i32 0
}

define i8 @gt_sub_nsw_wrong_const(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @gt_sub_nsw_wrong_const(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp samesign ugt i8 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[SUB]], 2
; CHECK-NEXT:    [[NEG:%.*]] = xor i8 [[SUB]], -1
; CHECK-NEXT:    [[ABSCOND:%.*]] = icmp samesign ult i8 [[SUB]], -2
; CHECK-NEXT:    [[ABS:%.*]] = select i1 [[ABSCOND]], i8 [[NEG]], i8 [[ADD]]
; CHECK-NEXT:    ret i8 [[ABS]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %cmp = icmp samesign ugt i8 %x, %y              ; x>y ? abs (x-y+2): 0
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %sub = sub i8 %x, %y
  %add = add i8 %sub, 2                           ; x-y+2
  %neg = xor i8 %sub, -1                          ; y-x-1
  %neg1 = sub i8 %neg, 1                          ; y-x-2
  %abscond = icmp samesign ult i8 %sub, -2
  %abs = select i1 %abscond, i8 %neg, i8 %add
  ret i8 %abs

cond.end:                                         ; preds = %entry, %cond.true
  ret i8 0
}
