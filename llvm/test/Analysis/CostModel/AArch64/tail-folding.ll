; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --filter "fold tail" --filter "estimated cost" --filter "costs" --filter "Selecting VF" --filter "loop costs" --version 5
; RUN: opt -passes=loop-vectorize -debug-only=loop-vectorize -disable-output -S < %s 2>&1 | FileCheck %s

; REQUIRE: asserts

target triple = "aarch64-unknown-linux-gnu"

; These tests check that if the only way to vectorize is to tail fold a store by
; masking then we properly account for the cost of creating a predicated block
; for each vector element.

define void @store_const_fixed_trip_count(ptr %dst) {
; CHECK-LABEL: 'store_const_fixed_trip_count'
; CHECK:  LV: can fold tail by masking.
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 2 for VF 1 For instruction: store i8 1, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Scalar loop costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 2 for VF 1 For instruction: store i8 1, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Scalar loop costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 8 for VF 2 For instruction: store i8 1, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 2 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 2 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 2 costs: 5.
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 16 for VF 4 For instruction: store i8 1, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 2 for VF 4 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 4 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 4 costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 32 for VF 8 For instruction: store i8 1, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 4 for VF 8 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 8 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 8 costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 64 for VF 16 For instruction: store i8 1, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 8 for VF 16 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 16 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 16 costs: 4.
; CHECK:  LV: Selecting VF: 1.
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %gep = getelementptr i8, ptr %dst, i64 %iv
  store i8 1, ptr %gep, align 1
  %iv.next = add i64 %iv, 1
  %ec = icmp eq i64 %iv.next, 7
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

define void @store_trunc_iv_fixed_trip_count(ptr %dst) {
; CHECK-LABEL: 'store_trunc_iv_fixed_trip_count'
; CHECK:  LV: can fold tail by masking.
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 2 for VF 1 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Scalar loop costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 2 for VF 1 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Scalar loop costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 10 for VF 2 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 2 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 2 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 2 costs: 6.
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 20 for VF 4 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 2 for VF 4 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 4 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 4 costs: 5.
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 40 for VF 8 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 4 for VF 8 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 8 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 8 costs: 5.
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 80 for VF 16 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 8 for VF 16 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 16 For instruction: %ec = icmp eq i64 %iv.next, 7
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 16 costs: 5.
; CHECK:  LV: Selecting VF: 1.
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.trunc = trunc i64 %iv to i8
  %gep = getelementptr i8, ptr %dst, i64 %iv
  store i8 %iv.trunc, ptr %gep, align 1
  %iv.next = add i64 %iv, 1
  %ec = icmp eq i64 %iv.next, 7
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

; With an unknown trip count we need to use optsize otherwise we use a scalar
; epilogue instead of tail folding.
define void @store_const_unknown_trip_count(ptr %dst, i64 %limit) optsize {
; CHECK-LABEL: 'store_const_unknown_trip_count'
; CHECK:  LV: can fold tail by masking.
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 2 for VF 1 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Scalar loop costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 2 for VF 1 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Scalar loop costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 10 for VF 2 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 2 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 2 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 2 costs: 6.
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 20 for VF 4 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 2 for VF 4 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 4 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 4 costs: 5.
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 40 for VF 8 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 4 for VF 8 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 8 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 8 costs: 5.
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 80 for VF 16 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 8 for VF 16 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 16 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 16 costs: 5.
; CHECK:  LV: Selecting VF: 1.
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.trunc = trunc i64 %iv to i8
  %gep = getelementptr i8, ptr %dst, i64 %iv
  store i8 %iv.trunc, ptr %gep, align 1
  %iv.next = add i64 %iv, 1
  %ec = icmp eq i64 %iv.next, %limit
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

define void @store_trunc_iv_unknown_trip_count(ptr %dst, i64 %limit) optsize {
; CHECK-LABEL: 'store_trunc_iv_unknown_trip_count'
; CHECK:  LV: can fold tail by masking.
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 2 for VF 1 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Scalar loop costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 2 for VF 1 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 1 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 1 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Scalar loop costs: 4.
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 10 for VF 2 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 1 for VF 2 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 2 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 2 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 2 costs: 6.
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 20 for VF 4 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 2 for VF 4 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 4 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 4 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 4 costs: 5.
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 40 for VF 8 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 4 for VF 8 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 8 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 8 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 8 costs: 5.
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %iv.trunc = trunc i64 %iv to i8
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: %gep = getelementptr i8, ptr %dst, i64 %iv
; CHECK:  LV: Found an estimated cost of 80 for VF 16 For instruction: store i8 %iv.trunc, ptr %gep, align 1
; CHECK:  LV: Found an estimated cost of 8 for VF 16 For instruction: %iv.next = add i64 %iv, 1
; CHECK:  LV: Found an estimated cost of 1 for VF 16 For instruction: %ec = icmp eq i64 %iv.next, %limit
; CHECK:  LV: Found an estimated cost of 0 for VF 16 For instruction: br i1 %ec, label %exit, label %loop
; CHECK:  LV: Vector loop of width 16 costs: 5.
; CHECK:  LV: Selecting VF: 1.
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.trunc = trunc i64 %iv to i8
  %gep = getelementptr i8, ptr %dst, i64 %iv
  store i8 %iv.trunc, ptr %gep, align 1
  %iv.next = add i64 %iv, 1
  %ec = icmp eq i64 %iv.next, %limit
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}
